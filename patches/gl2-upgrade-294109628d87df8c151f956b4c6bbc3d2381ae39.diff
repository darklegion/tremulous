diff --git a/src/renderercommon/qgl.h b/src/renderercommon/qgl.h
index c3f0a87..2ddb1a7 100644
--- a/src/renderercommon/qgl.h
+++ b/src/renderercommon/qgl.h
@@ -623,7 +623,7 @@ extern void (APIENTRYP qglUnlockArraysEXT) (void);
 	GLE(GLvoid, TextureParameteriEXT, GLuint texture, GLenum target, GLenum pname, GLint param) \
 	GLE(GLvoid, TextureImage2DEXT, GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels) \
 	GLE(GLvoid, TextureSubImage2DEXT, GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) \
-	GLE(GLvoid, CopyTextureImage2DEXT, GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) \
+	GLE(GLvoid, CopyTextureSubImage2DEXT, GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) \
 	GLE(GLvoid, CompressedTextureImage2DEXT, GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data) \
 	GLE(GLvoid, CompressedTextureSubImage2DEXT, GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data) \
 	GLE(GLvoid, GenerateTextureMipmapEXT, GLuint texture, GLenum target) \
diff --git a/src/renderergl2/glsl/lightall_fp.glsl b/src/renderergl2/glsl/lightall_fp.glsl
index 9e53d4a..5cb8233 100644
--- a/src/renderergl2/glsl/lightall_fp.glsl
+++ b/src/renderergl2/glsl/lightall_fp.glsl
@@ -53,14 +53,9 @@ varying vec4      var_ColorAmbient;
 #endif
 
 #if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT))
-  #if defined(USE_VERT_TANGENT_SPACE)
 varying vec4   var_Normal;
 varying vec4   var_Tangent;
 varying vec4   var_Bitangent;
-  #else
-varying vec3   var_Normal;
-varying vec3   var_ViewDir;
-  #endif
 #endif
 
 #if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
@@ -196,25 +191,6 @@ float CalcLightAttenuation(float point, float normDist)
 	return attenuation;
 }
 
-// from http://www.thetenthplanet.de/archives/1180
-mat3 cotangent_frame( vec3 N, vec3 p, vec2 uv )
-{
-	// get edge vectors of the pixel triangle
-	vec3 dp1 = dFdx( p );
-	vec3 dp2 = dFdy( p );
-	vec2 duv1 = dFdx( uv );
-	vec2 duv2 = dFdy( uv );
-
-	// solve the linear system
-	vec3 dp2perp = cross( dp2, N );
-	vec3 dp1perp = cross( N, dp1 );
-	vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
-	vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
-
-	// construct a scale-invariant frame 
-	float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
-	return mat3( T * invmax, B * invmax, N );
-}
 
 void main()
 {
@@ -223,13 +199,8 @@ void main()
 	float NL, NH, NE, EH, attenuation;
 
 #if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
-  #if defined(USE_VERT_TANGENT_SPACE)
 	mat3 tangentToWorld = mat3(var_Tangent.xyz, var_Bitangent.xyz, var_Normal.xyz);
 	viewDir = vec3(var_Normal.w, var_Tangent.w, var_Bitangent.w);
-  #else
-	mat3 tangentToWorld = cotangent_frame(var_Normal, -var_ViewDir, var_TexCoords.xy);
-	viewDir = var_ViewDir;
-  #endif
 	E = normalize(viewDir);
 #endif
 
@@ -303,6 +274,9 @@ void main()
 	ambientColor = lightColor;
 	float surfNL = clamp(dot(var_Normal.xyz, L), 0.0, 1.0);
 
+	// reserve 25% ambient to avoid black areas on normalmaps
+	lightColor *= 0.75;
+
 	// Scale the incoming light to compensate for the baked-in light angle
 	// attenuation.
 	lightColor /= max(surfNL, 0.25);
diff --git a/src/renderergl2/glsl/lightall_vp.glsl b/src/renderergl2/glsl/lightall_vp.glsl
index 783885e..e5b3c4f 100644
--- a/src/renderergl2/glsl/lightall_vp.glsl
+++ b/src/renderergl2/glsl/lightall_vp.glsl
@@ -6,16 +6,12 @@ attribute vec4 attr_Color;
 
 attribute vec3 attr_Position;
 attribute vec3 attr_Normal;
-#if defined(USE_VERT_TANGENT_SPACE)
 attribute vec4 attr_Tangent;
-#endif
 
 #if defined(USE_VERTEX_ANIMATION)
 attribute vec3 attr_Position2;
 attribute vec3 attr_Normal2;
-  #if defined(USE_VERT_TANGENT_SPACE)
 attribute vec4 attr_Tangent2;
-  #endif
 #endif
 
 #if defined(USE_LIGHT) && !defined(USE_LIGHT_VECTOR)
@@ -74,14 +70,9 @@ varying vec4   var_ColorAmbient;
 #endif
 
 #if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
-  #if defined(USE_VERT_TANGENT_SPACE)
 varying vec4   var_Normal;
 varying vec4   var_Tangent;
 varying vec4   var_Bitangent;
-  #else
-varying vec3   var_Normal;
-varying vec3   var_ViewDir;
-  #endif
 #endif
 
 #if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
@@ -157,13 +148,13 @@ void main()
 #if defined(USE_VERTEX_ANIMATION)
 	vec3 position  = mix(attr_Position,    attr_Position2,    u_VertexLerp);
 	vec3 normal    = mix(attr_Normal,      attr_Normal2,      u_VertexLerp);
-  #if defined(USE_VERT_TANGENT_SPACE) && defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
+  #if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
 	vec3 tangent   = mix(attr_Tangent.xyz, attr_Tangent2.xyz, u_VertexLerp);
   #endif
 #else
 	vec3 position  = attr_Position;
 	vec3 normal    = attr_Normal;
-  #if defined(USE_VERT_TANGENT_SPACE) && defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
+  #if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
 	vec3 tangent   = attr_Tangent.xyz;
   #endif
 #endif
@@ -185,12 +176,12 @@ void main()
 #if defined(USE_MODELMATRIX)
 	position  = (u_ModelMatrix * vec4(position, 1.0)).xyz;
 	normal    = (u_ModelMatrix * vec4(normal,   0.0)).xyz;
-  #if defined(USE_VERT_TANGENT_SPACE) && defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
+  #if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
 	tangent   = (u_ModelMatrix * vec4(tangent,  0.0)).xyz;
   #endif
 #endif
 
-#if defined(USE_VERT_TANGENT_SPACE) && defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
+#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
 	vec3 bitangent = cross(normal, tangent) * attr_Tangent.w;
 #endif
 
@@ -247,14 +238,9 @@ void main()
 
 #if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)
 	vec3 viewDir = u_ViewOrigin - position;
-  #if defined(USE_VERT_TANGENT_SPACE)
 	// store view direction in tangent space to save on varyings
 	var_Normal    = vec4(normal,    viewDir.x);
 	var_Tangent   = vec4(tangent,   viewDir.y);
 	var_Bitangent = vec4(bitangent, viewDir.z);
-  #else
-	var_Normal = normal;
-	var_ViewDir = viewDir;
-  #endif
 #endif
 }
diff --git a/src/renderergl2/tr_animation.c b/src/renderergl2/tr_animation.c
index b5dbc33..d57fb4b 100644
--- a/src/renderergl2/tr_animation.c
+++ b/src/renderergl2/tr_animation.c
@@ -413,10 +413,10 @@ void RB_MDRSurfaceAnim( mdrSurface_t *surface )
 		tess.xyz[baseVertex + j][1] = tempVert[1];
 		tess.xyz[baseVertex + j][2] = tempVert[2];
 
-		R_VaoPackNormal((byte *)&tess.normal[baseVertex + j], tempNormal);
+		R_VaoPackNormal(tess.normal[baseVertex + j], tempNormal);
 
-		tess.texCoords[baseVertex + j][0][0] = v->texCoords[0];
-		tess.texCoords[baseVertex + j][0][1] = v->texCoords[1];
+		tess.texCoords[baseVertex + j][0] = v->texCoords[0];
+		tess.texCoords[baseVertex + j][1] = v->texCoords[1];
 
 		v = (mdrVertex_t *)&v->weights[v->numWeights];
 	}
diff --git a/src/renderergl2/tr_backend.c b/src/renderergl2/tr_backend.c
index 0979a9d..b4e79dc 100644
--- a/src/renderergl2/tr_backend.c
+++ b/src/renderergl2/tr_backend.c
@@ -713,9 +713,6 @@ void	RB_SetGL2D (void) {
 	// set time for 2D shaders
 	backEnd.refdef.time = ri.Milliseconds();
 	backEnd.refdef.floatTime = backEnd.refdef.time * 0.001f;
-
-	// reset color scaling
-	backEnd.refdef.colorScale = 1.0f;
 }
 
 
@@ -885,43 +882,43 @@ const void *RB_StretchPic ( const void *data ) {
 	tess.indexes[ numIndexes + 5 ] = numVerts + 1;
 
 	{
-		vec4_t color;
+		uint16_t color[4];
 
-		VectorScale4(backEnd.color2D, 1.0f / 255.0f, color);
+		VectorScale4(backEnd.color2D, 257, color);
 
-		VectorCopy4(color, tess.vertexColors[ numVerts ]);
-		VectorCopy4(color, tess.vertexColors[ numVerts + 1]);
-		VectorCopy4(color, tess.vertexColors[ numVerts + 2]);
-		VectorCopy4(color, tess.vertexColors[ numVerts + 3 ]);
+		VectorCopy4(color, tess.color[ numVerts ]);
+		VectorCopy4(color, tess.color[ numVerts + 1]);
+		VectorCopy4(color, tess.color[ numVerts + 2]);
+		VectorCopy4(color, tess.color[ numVerts + 3 ]);
 	}
 
 	tess.xyz[ numVerts ][0] = cmd->x;
 	tess.xyz[ numVerts ][1] = cmd->y;
 	tess.xyz[ numVerts ][2] = 0;
 
-	tess.texCoords[ numVerts ][0][0] = cmd->s1;
-	tess.texCoords[ numVerts ][0][1] = cmd->t1;
+	tess.texCoords[ numVerts ][0] = cmd->s1;
+	tess.texCoords[ numVerts ][1] = cmd->t1;
 
 	tess.xyz[ numVerts + 1 ][0] = cmd->x + cmd->w;
 	tess.xyz[ numVerts + 1 ][1] = cmd->y;
 	tess.xyz[ numVerts + 1 ][2] = 0;
 
-	tess.texCoords[ numVerts + 1 ][0][0] = cmd->s2;
-	tess.texCoords[ numVerts + 1 ][0][1] = cmd->t1;
+	tess.texCoords[ numVerts + 1 ][0] = cmd->s2;
+	tess.texCoords[ numVerts + 1 ][1] = cmd->t1;
 
 	tess.xyz[ numVerts + 2 ][0] = cmd->x + cmd->w;
 	tess.xyz[ numVerts + 2 ][1] = cmd->y + cmd->h;
 	tess.xyz[ numVerts + 2 ][2] = 0;
 
-	tess.texCoords[ numVerts + 2 ][0][0] = cmd->s2;
-	tess.texCoords[ numVerts + 2 ][0][1] = cmd->t2;
+	tess.texCoords[ numVerts + 2 ][0] = cmd->s2;
+	tess.texCoords[ numVerts + 2 ][1] = cmd->t2;
 
 	tess.xyz[ numVerts + 3 ][0] = cmd->x;
 	tess.xyz[ numVerts + 3 ][1] = cmd->y + cmd->h;
 	tess.xyz[ numVerts + 3 ][2] = 0;
 
-	tess.texCoords[ numVerts + 3 ][0][0] = cmd->s1;
-	tess.texCoords[ numVerts + 3 ][0][1] = cmd->t2;
+	tess.texCoords[ numVerts + 3 ][0] = cmd->s1;
+	tess.texCoords[ numVerts + 3 ][1] = cmd->t2;
 
 	return (const void *)(cmd + 1);
 }
@@ -975,7 +972,9 @@ const void	*RB_DrawSurfs( const void *data ) {
 		else if (tr.renderFbo == NULL && tr.renderDepthImage)
 		{
 			// If we're rendering directly to the screen, copy the depth to a texture
-			qglCopyTextureImage2DEXT(tr.renderDepthImage->texnum, GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT24, 0, 0, glConfig.vidWidth, glConfig.vidHeight, 0);
+			// This is incredibly slow on Intel Graphics, so just skip it on there
+			if (!glRefConfig.intelGraphics)
+				qglCopyTextureSubImage2DEXT(tr.renderDepthImage->texnum, GL_TEXTURE_2D, 0, 0, 0, 0, 0, glConfig.vidWidth, glConfig.vidHeight);
 		}
 
 		if (tr.hdrDepthFbo)
@@ -1479,14 +1478,14 @@ const void *RB_CapShadowMap(const void *data)
 		{
 			if (tr.shadowCubemaps[cmd->map])
 			{
-				qglCopyTextureImage2DEXT(tr.shadowCubemaps[cmd->map]->texnum, GL_TEXTURE_CUBE_MAP_POSITIVE_X + cmd->cubeSide, 0, GL_RGBA8, backEnd.refdef.x, glConfig.vidHeight - ( backEnd.refdef.y + PSHADOW_MAP_SIZE ), PSHADOW_MAP_SIZE, PSHADOW_MAP_SIZE, 0);
+				qglCopyTextureSubImage2DEXT(tr.shadowCubemaps[cmd->map]->texnum, GL_TEXTURE_CUBE_MAP_POSITIVE_X + cmd->cubeSide, 0, 0, 0, backEnd.refdef.x, glConfig.vidHeight - ( backEnd.refdef.y + PSHADOW_MAP_SIZE ), PSHADOW_MAP_SIZE, PSHADOW_MAP_SIZE);
 			}
 		}
 		else
 		{
 			if (tr.pshadowMaps[cmd->map])
 			{
-				qglCopyTextureImage2DEXT(tr.pshadowMaps[cmd->map]->texnum, GL_TEXTURE_2D, 0, GL_RGBA8, backEnd.refdef.x, glConfig.vidHeight - (backEnd.refdef.y + PSHADOW_MAP_SIZE), PSHADOW_MAP_SIZE, PSHADOW_MAP_SIZE, 0);
+				qglCopyTextureSubImage2DEXT(tr.pshadowMaps[cmd->map]->texnum, GL_TEXTURE_2D, 0, 0, 0, backEnd.refdef.x, glConfig.vidHeight - (backEnd.refdef.y + PSHADOW_MAP_SIZE), PSHADOW_MAP_SIZE, PSHADOW_MAP_SIZE);
 			}
 		}
 	}
diff --git a/src/renderergl2/tr_bsp.c b/src/renderergl2/tr_bsp.c
index 288257b..8d65159 100644
--- a/src/renderergl2/tr_bsp.c
+++ b/src/renderergl2/tr_bsp.c
@@ -106,11 +106,7 @@ static	void R_ColorShiftLightingBytes( byte in[4], byte out[4] ) {
 	int		shift, r, g, b;
 
 	// shift the color data based on overbright range
-#if defined(USE_OVERBRIGHT)
 	shift = r_mapOverBrightBits->integer - tr.overbrightBits;
-#else
-	shift = 0;
-#endif
 
 	// shift the data based on overbright range
 	r = in[0] << shift;
@@ -141,13 +137,10 @@ R_ColorShiftLightingFloats
 
 ===============
 */
-static void R_ColorShiftLightingFloats(float in[4], float out[4], float scale )
+static void R_ColorShiftLightingFloats(float in[4], float out[4])
 {
 	float	r, g, b;
-
-#if defined(USE_OVERBRIGHT)
-	scale *= 1 << (r_mapOverBrightBits->integer - tr.overbrightBits);
-#endif
+	float   scale = (1 << (r_mapOverBrightBits->integer - tr.overbrightBits)) / 255.0f;
 
 	r = in[0] * scale;
 	g = in[1] * scale;
@@ -192,12 +185,11 @@ void ColorToRGBM(const vec3_t color, unsigned char rgbm[4])
 	rgbm[2] = (unsigned char) (sample[2] * 255);
 }
 
-void ColorToRGBA16F(const vec3_t color, unsigned short rgba16f[4])
+void ColorToRGB16(const vec3_t color, uint16_t rgb16[3])
 {
-	rgba16f[0] = FloatToHalf(color[0]);
-	rgba16f[1] = FloatToHalf(color[1]);
-	rgba16f[2] = FloatToHalf(color[2]);
-	rgba16f[3] = FloatToHalf(1.0f);
+	rgb16[0] = color[0] * 65535.0f + 0.5f;
+	rgb16[1] = color[1] * 65535.0f + 0.5f;
+	rgb16[2] = color[2] * 65535.0f + 0.5f;
 }
 
 
@@ -208,13 +200,14 @@ R_LoadLightmaps
 ===============
 */
 #define	DEFAULT_LIGHTMAP_SIZE	128
-#define MAX_LIGHTMAP_PAGES 2
 static	void R_LoadLightmaps( lump_t *l, lump_t *surfs ) {
+	imgFlags_t  imgFlags = IMGFLAG_NOLIGHTSCALE | IMGFLAG_NO_COMPRESSION | IMGFLAG_CLAMPTOEDGE;
 	byte		*buf, *buf_p;
 	dsurface_t  *surf;
 	int			len;
 	byte		*image;
 	int			i, j, numLightmaps, textureInternalFormat = 0;
+	int			numLightmapsPerPage = 16;
 	float maxIntensity = 0;
 	double sumIntensity = 0;
 
@@ -254,36 +247,24 @@ static	void R_LoadLightmaps( lump_t *l, lump_t *surfs ) {
 	if (tr.worldDeluxeMapping)
 		numLightmaps >>= 1;
 
-	if(numLightmaps == 1)
-	{
-		//FIXME: HACK: maps with only one lightmap turn up fullbright for some reason.
-		//this avoids this, but isn't the correct solution.
-		numLightmaps++;
-	}
-	else if (r_mergeLightmaps->integer && numLightmaps >= 1024 )
-	{
-		// FIXME: fat light maps don't support more than 1024 light maps
-		ri.Printf(PRINT_WARNING, "WARNING: number of lightmaps > 1024\n");
-		numLightmaps = 1024;
-	}
-
-	// use fat lightmaps of an appropriate size
+	// Use fat lightmaps of an appropriate size.
 	if (r_mergeLightmaps->integer)
 	{
-		tr.fatLightmapSize = 512;
-		tr.fatLightmapStep = tr.fatLightmapSize / tr.lightmapSize;
+		int maxLightmapsPerAxis = glConfig.maxTextureSize / tr.lightmapSize;
+		int lightmapCols = 4, lightmapRows = 4;
 
-		// at most MAX_LIGHTMAP_PAGES
-		while (tr.fatLightmapStep * tr.fatLightmapStep * MAX_LIGHTMAP_PAGES < numLightmaps && tr.fatLightmapSize != glConfig.maxTextureSize )
-		{
-			tr.fatLightmapSize <<= 1;
-			tr.fatLightmapStep = tr.fatLightmapSize / tr.lightmapSize;
-		}
+		// Increase width at first, then height.
+		while (lightmapCols * lightmapRows < numLightmaps && lightmapCols != maxLightmapsPerAxis)
+			lightmapCols <<= 1;
 
-		tr.numLightmaps = numLightmaps / (tr.fatLightmapStep * tr.fatLightmapStep);
+		while (lightmapCols * lightmapRows < numLightmaps && lightmapRows != maxLightmapsPerAxis)
+			lightmapRows <<= 1;
 
-		if (numLightmaps % (tr.fatLightmapStep * tr.fatLightmapStep) != 0)
-			tr.numLightmaps++;
+		tr.fatLightmapCols  = lightmapCols;
+		tr.fatLightmapRows  = lightmapRows;
+		numLightmapsPerPage = lightmapCols * lightmapRows;
+
+		tr.numLightmaps = (numLightmaps + (numLightmapsPerPage - 1)) / numLightmapsPerPage;
 	}
 	else
 	{
@@ -293,25 +274,30 @@ static	void R_LoadLightmaps( lump_t *l, lump_t *surfs ) {
 	tr.lightmaps = ri.Hunk_Alloc( tr.numLightmaps * sizeof(image_t *), h_low );
 
 	if (tr.worldDeluxeMapping)
-	{
 		tr.deluxemaps = ri.Hunk_Alloc( tr.numLightmaps * sizeof(image_t *), h_low );
-	}
 
-	if (glRefConfig.floatLightmap)
-		textureInternalFormat = GL_RGBA16F_ARB;
-	else
-		textureInternalFormat = GL_RGBA8;
+	textureInternalFormat = GL_RGBA8;
+	if (r_hdr->integer)
+	{
+		// Check for the first hdr lightmap, if it exists, use GL_RGBA16 for textures.
+		char filename[MAX_QPATH];
+
+		Com_sprintf(filename, sizeof(filename), "maps/%s/lm_0000.hdr", s_worldData.baseName);
+		if (ri.FS_FileExists(filename))
+			textureInternalFormat = GL_RGBA16;
+	}
 
 	if (r_mergeLightmaps->integer)
 	{
+		int width  = tr.fatLightmapCols * tr.lightmapSize;
+		int height = tr.fatLightmapRows * tr.lightmapSize;
+
 		for (i = 0; i < tr.numLightmaps; i++)
 		{
-			tr.lightmaps[i] = R_CreateImage(va("_fatlightmap%d", i), NULL, tr.fatLightmapSize, tr.fatLightmapSize, IMGTYPE_COLORALPHA, IMGFLAG_NOLIGHTSCALE | IMGFLAG_NO_COMPRESSION | IMGFLAG_CLAMPTOEDGE, textureInternalFormat );
+			tr.lightmaps[i] = R_CreateImage(va("_fatlightmap%d", i), NULL, width, height, IMGTYPE_COLORALPHA, imgFlags, textureInternalFormat);
 
 			if (tr.worldDeluxeMapping)
-			{
-				tr.deluxemaps[i] = R_CreateImage(va("_fatdeluxemap%d", i), NULL, tr.fatLightmapSize, tr.fatLightmapSize, IMGTYPE_DELUXE, IMGFLAG_NOLIGHTSCALE | IMGFLAG_NO_COMPRESSION | IMGFLAG_CLAMPTOEDGE, 0 );
-			}
+				tr.deluxemaps[i] = R_CreateImage(va("_fatdeluxemap%d", i), NULL, width, height, IMGTYPE_DELUXE, imgFlags, 0);
 		}
 	}
 
@@ -323,11 +309,11 @@ static	void R_LoadLightmaps( lump_t *l, lump_t *surfs ) {
 
 		if (r_mergeLightmaps->integer)
 		{
-			int lightmaponpage = i % (tr.fatLightmapStep * tr.fatLightmapStep);
-			xoff = (lightmaponpage % tr.fatLightmapStep) * tr.lightmapSize;
-			yoff = (lightmaponpage / tr.fatLightmapStep) * tr.lightmapSize;
+			int lightmaponpage = i % numLightmapsPerPage;
+			xoff = (lightmaponpage % tr.fatLightmapCols) * tr.lightmapSize;
+			yoff = (lightmaponpage / tr.fatLightmapCols) * tr.lightmapSize;
 
-			lightmapnum /= (tr.fatLightmapStep * tr.fatLightmapStep);
+			lightmapnum /= numLightmapsPerPage;
 		}
 
 		// if (tr.worldLightmapping)
@@ -337,7 +323,7 @@ static	void R_LoadLightmaps( lump_t *l, lump_t *surfs ) {
 			int size = 0;
 
 			// look for hdr lightmaps
-			if (r_hdr->integer)
+			if (textureInternalFormat == GL_RGBA16)
 			{
 				Com_sprintf( filename, sizeof( filename ), "maps/%s/lm_%04d.hdr", s_worldData.baseName, i * (tr.worldDeluxeMapping ? 2 : 1) );
 				//ri.Printf(PRINT_ALL, "looking for %s\n", filename);
@@ -347,47 +333,37 @@ static	void R_LoadLightmaps( lump_t *l, lump_t *surfs ) {
 
 			if (hdrLightmap)
 			{
-				byte *p = hdrLightmap;
+				byte *p = hdrLightmap, *end = hdrLightmap + size;
 				//ri.Printf(PRINT_ALL, "found!\n");
 				
 				/* FIXME: don't just skip over this header and actually parse it */
-				while (size && !(*p == '\n' && *(p+1) == '\n'))
-				{
-					size--;
+				while (p < end && !(*p == '\n' && *(p+1) == '\n'))
 					p++;
-				}
-
-				if (!size)
-					ri.Error(ERR_DROP, "Bad header for %s!", filename);
 
-				size -= 2;
 				p += 2;
 				
-				while (size && !(*p == '\n'))
-				{
-					size--;
+				while (p < end && !(*p == '\n'))
 					p++;
-				}
 
-				size--;
 				p++;
 
-				buf_p = (byte *)p;
+				if (p >= end)
+					ri.Error(ERR_DROP, "Bad header for %s!", filename);
+
+				buf_p = p;
 
 #if 0 // HDRFILE_RGBE
-				if (size != tr.lightmapSize * tr.lightmapSize * 4)
+				if ((int)(end - hdrLightmap) != tr.lightmapSize * tr.lightmapSize * 4)
 					ri.Error(ERR_DROP, "Bad size for %s (%i)!", filename, size);
 #else // HDRFILE_FLOAT
-				if (size != tr.lightmapSize * tr.lightmapSize * 12)
+				if ((int)(end - hdrLightmap) != tr.lightmapSize * tr.lightmapSize * 12)
 					ri.Error(ERR_DROP, "Bad size for %s (%i)!", filename, size);
 #endif
 			}
 			else
 			{
-				if (tr.worldDeluxeMapping)
-					buf_p = buf + (i * 2) * tr.lightmapSize * tr.lightmapSize * 3;
-				else
-					buf_p = buf + i * tr.lightmapSize * tr.lightmapSize * 3;
+				int imgOffset = tr.worldDeluxeMapping ? i * 2 : i;
+				buf_p = buf + imgOffset * tr.lightmapSize * tr.lightmapSize * 3;
 			}
 
 			for ( j = 0 ; j < tr.lightmapSize * tr.lightmapSize; j++ ) 
@@ -411,14 +387,12 @@ static	void R_LoadLightmaps( lump_t *l, lump_t *surfs ) {
 #endif
 					color[3] = 1.0f;
 
-					R_ColorShiftLightingFloats(color, color, 1.0f/255.0f);
+					R_ColorShiftLightingFloats(color, color);
 
-					if (glRefConfig.floatLightmap)
-						ColorToRGBA16F(color, (unsigned short *)(&image[j*8]));
-					else
-						ColorToRGBM(color, &image[j*4]);
+					ColorToRGB16(color, (uint16_t *)(&image[j * 8]));
+					((uint16_t *)(&image[j * 8]))[3] = 65535;
 				}
-				else if (glRefConfig.floatLightmap)
+				else if (textureInternalFormat == GL_RGBA16)
 				{
 					vec4_t color;
 
@@ -438,9 +412,10 @@ static	void R_LoadLightmaps( lump_t *l, lump_t *surfs ) {
 					}
 					color[3] = 1.0f;
 
-					R_ColorShiftLightingFloats(color, color, 1.0f/255.0f);
+					R_ColorShiftLightingFloats(color, color);
 
-					ColorToRGBA16F(color, (unsigned short *)(&image[j*8]));
+					ColorToRGB16(color, (uint16_t *)(&image[j * 8]));
+					((uint16_t *)(&image[j * 8]))[3] = 65535;
 				}
 				else
 				{
@@ -480,9 +455,9 @@ static	void R_LoadLightmaps( lump_t *l, lump_t *surfs ) {
 			}
 
 			if (r_mergeLightmaps->integer)
-				R_UpdateSubImage(tr.lightmaps[lightmapnum], image, xoff, yoff, tr.lightmapSize, tr.lightmapSize);
+				R_UpdateSubImage(tr.lightmaps[lightmapnum], image, xoff, yoff, tr.lightmapSize, tr.lightmapSize, textureInternalFormat);
 			else
-				tr.lightmaps[i] = R_CreateImage(va("*lightmap%d", i), image, tr.lightmapSize, tr.lightmapSize, IMGTYPE_COLORALPHA, IMGFLAG_NOLIGHTSCALE | IMGFLAG_NO_COMPRESSION | IMGFLAG_CLAMPTOEDGE, textureInternalFormat );
+				tr.lightmaps[i] = R_CreateImage(va("*lightmap%d", i), image, tr.lightmapSize, tr.lightmapSize, IMGTYPE_COLORALPHA, imgFlags, textureInternalFormat );
 
 			if (hdrLightmap)
 				ri.FS_FreeFile(hdrLightmap);
@@ -509,13 +484,9 @@ static	void R_LoadLightmaps( lump_t *l, lump_t *surfs ) {
 			}
 
 			if (r_mergeLightmaps->integer)
-			{
-				R_UpdateSubImage(tr.deluxemaps[lightmapnum], image, xoff, yoff, tr.lightmapSize, tr.lightmapSize );
-			}
+				R_UpdateSubImage(tr.deluxemaps[lightmapnum], image, xoff, yoff, tr.lightmapSize, tr.lightmapSize, GL_RGBA8 );
 			else
-			{
-				tr.deluxemaps[i] = R_CreateImage(va("*deluxemap%d", i), image, tr.lightmapSize, tr.lightmapSize, IMGTYPE_DELUXE, IMGFLAG_NOLIGHTSCALE | IMGFLAG_NO_COMPRESSION | IMGFLAG_CLAMPTOEDGE, 0 );
-			}
+				tr.deluxemaps[i] = R_CreateImage(va("*deluxemap%d", i), image, tr.lightmapSize, tr.lightmapSize, IMGTYPE_DELUXE, imgFlags, 0 );
 		}
 	}
 
@@ -535,15 +506,10 @@ static float FatPackU(float input, int lightmapnum)
 	if (tr.worldDeluxeMapping)
 		lightmapnum >>= 1;
 
-	if(tr.fatLightmapSize > 0)
+	if (tr.fatLightmapCols > 0)
 	{
-		int             x;
-
-		lightmapnum %= (tr.fatLightmapStep * tr.fatLightmapStep);
-
-		x = lightmapnum % tr.fatLightmapStep;
-
-		return (input / ((float)tr.fatLightmapStep)) + ((1.0 / ((float)tr.fatLightmapStep)) * (float)x);
+		lightmapnum %= (tr.fatLightmapCols * tr.fatLightmapRows);
+		return (input + (lightmapnum % tr.fatLightmapCols)) / (float)(tr.fatLightmapCols);
 	}
 
 	return input;
@@ -557,15 +523,10 @@ static float FatPackV(float input, int lightmapnum)
 	if (tr.worldDeluxeMapping)
 		lightmapnum >>= 1;
 
-	if(tr.fatLightmapSize > 0)
+	if (tr.fatLightmapCols > 0)
 	{
-		int             y;
-
-		lightmapnum %= (tr.fatLightmapStep * tr.fatLightmapStep);
-
-		y = lightmapnum / tr.fatLightmapStep;
-
-		return (input / ((float)tr.fatLightmapStep)) + ((1.0 / ((float)tr.fatLightmapStep)) * (float)y);
+		lightmapnum %= (tr.fatLightmapCols * tr.fatLightmapRows);
+		return (input + (lightmapnum / tr.fatLightmapCols)) / (float)(tr.fatLightmapRows);
 	}
 
 	return input;
@@ -580,10 +541,8 @@ static int FatLightmap(int lightmapnum)
 	if (tr.worldDeluxeMapping)
 		lightmapnum >>= 1;
 
-	if (tr.fatLightmapSize > 0)
-	{
-		return lightmapnum / (tr.fatLightmapStep * tr.fatLightmapStep);
-	}
+	if (tr.fatLightmapCols > 0)
+		return lightmapnum / (tr.fatLightmapCols * tr.fatLightmapRows);
 	
 	return lightmapnum;
 }
@@ -668,6 +627,67 @@ static shader_t *ShaderForShaderNum( int shaderNum, int lightmapNum ) {
 	return shader;
 }
 
+void LoadDrawVertToSrfVert(srfVert_t *s, drawVert_t *d, int realLightmapNum, float hdrVertColors[3], vec3_t *bounds)
+{
+	vec4_t v;
+
+	s->xyz[0] = LittleFloat(d->xyz[0]);
+	s->xyz[1] = LittleFloat(d->xyz[1]);
+	s->xyz[2] = LittleFloat(d->xyz[2]);
+
+	if (bounds)
+		AddPointToBounds(s->xyz, bounds[0], bounds[1]);
+
+	s->st[0] = LittleFloat(d->st[0]);
+	s->st[1] = LittleFloat(d->st[1]);
+
+	if (realLightmapNum >= 0)
+	{
+		s->lightmap[0] = FatPackU(LittleFloat(d->lightmap[0]), realLightmapNum);
+		s->lightmap[1] = FatPackV(LittleFloat(d->lightmap[1]), realLightmapNum);
+	}
+	else
+	{
+		s->lightmap[0] = LittleFloat(d->lightmap[0]);
+		s->lightmap[1] = LittleFloat(d->lightmap[1]);
+	}
+
+	v[0] = LittleFloat(d->normal[0]);
+	v[1] = LittleFloat(d->normal[1]);
+	v[2] = LittleFloat(d->normal[2]);
+
+	R_VaoPackNormal(s->normal, v);
+
+	if (hdrVertColors)
+	{
+		v[0] = hdrVertColors[0];
+		v[1] = hdrVertColors[1];
+		v[2] = hdrVertColors[2];
+	}
+	else
+	{
+		//hack: convert LDR vertex colors to HDR
+		if (r_hdr->integer)
+		{
+			v[0] = MAX(d->color[0], 0.499f);
+			v[1] = MAX(d->color[1], 0.499f);
+			v[2] = MAX(d->color[2], 0.499f);
+		}
+		else
+		{
+			v[0] = d->color[0];
+			v[1] = d->color[1];
+			v[2] = d->color[2];
+		}
+
+	}
+	v[3] = d->color[3] / 255.0f;
+
+	R_ColorShiftLightingFloats(v, v);
+	R_VaoPackColor(s->color, v);
+}
+
+
 /*
 ===============
 ParseFace
@@ -715,50 +735,7 @@ static void ParseFace( dsurface_t *ds, drawVert_t *verts, float *hdrVertColors,
 	ClearBounds(surf->cullinfo.bounds[0], surf->cullinfo.bounds[1]);
 	verts += LittleLong(ds->firstVert);
 	for(i = 0; i < numVerts; i++)
-	{
-		vec4_t color;
-
-		for(j = 0; j < 3; j++)
-		{
-			cv->verts[i].xyz[j] = LittleFloat(verts[i].xyz[j]);
-			cv->verts[i].normal[j] = LittleFloat(verts[i].normal[j]);
-		}
-		AddPointToBounds(cv->verts[i].xyz, surf->cullinfo.bounds[0], surf->cullinfo.bounds[1]);
-		for(j = 0; j < 2; j++)
-		{
-			cv->verts[i].st[j] = LittleFloat(verts[i].st[j]);
-			//cv->verts[i].lightmap[j] = LittleFloat(verts[i].lightmap[j]);
-		}
-		cv->verts[i].lightmap[0] = FatPackU(LittleFloat(verts[i].lightmap[0]), realLightmapNum);
-		cv->verts[i].lightmap[1] = FatPackV(LittleFloat(verts[i].lightmap[1]), realLightmapNum);
-
-		if (hdrVertColors)
-		{
-			color[0] = hdrVertColors[(ds->firstVert + i) * 3    ];
-			color[1] = hdrVertColors[(ds->firstVert + i) * 3 + 1];
-			color[2] = hdrVertColors[(ds->firstVert + i) * 3 + 2];
-		}
-		else
-		{
-			//hack: convert LDR vertex colors to HDR
-			if (r_hdr->integer)
-			{
-				color[0] = MAX(verts[i].color[0], 0.499f);
-				color[1] = MAX(verts[i].color[1], 0.499f);
-				color[2] = MAX(verts[i].color[2], 0.499f);
-			}
-			else
-			{
-				color[0] = verts[i].color[0];
-				color[1] = verts[i].color[1];
-				color[2] = verts[i].color[2];
-			}
-
-		}
-		color[3] = verts[i].color[3] / 255.0f;
-
-		R_ColorShiftLightingFloats( color, cv->verts[i].vertexColors, 1.0f / 255.0f );
-	}
+		LoadDrawVertToSrfVert(&cv->verts[i], &verts[i], realLightmapNum, hdrVertColors ? hdrVertColors + (ds->firstVert + i) * 3 : NULL, surf->cullinfo.bounds);
 
 	// copy triangles
 	badTriangles = 0;
@@ -799,7 +776,6 @@ static void ParseFace( dsurface_t *ds, drawVert_t *verts, float *hdrVertColors,
 
 	surf->data = (surfaceType_t *)cv;
 
-#ifdef USE_VERT_TANGENT_SPACE
 	// Calculate tangent spaces
 	{
 		srfVert_t      *dv[3];
@@ -813,7 +789,6 @@ static void ParseFace( dsurface_t *ds, drawVert_t *verts, float *hdrVertColors,
 			R_CalcTangentVectors(dv);
 		}
 	}
-#endif
 }
 
 
@@ -824,7 +799,7 @@ ParseMesh
 */
 static void ParseMesh ( dsurface_t *ds, drawVert_t *verts, float *hdrVertColors, msurface_t *surf ) {
 	srfBspSurface_t	*grid = (srfBspSurface_t *)surf->data;
-	int				i, j;
+	int				i;
 	int				width, height, numPoints;
 	srfVert_t points[MAX_PATCH_SIZE*MAX_PATCH_SIZE];
 	vec3_t			bounds[2];
@@ -859,49 +834,7 @@ static void ParseMesh ( dsurface_t *ds, drawVert_t *verts, float *hdrVertColors,
 	verts += LittleLong( ds->firstVert );
 	numPoints = width * height;
 	for(i = 0; i < numPoints; i++)
-	{
-		vec4_t color;
-
-		for(j = 0; j < 3; j++)
-		{
-			points[i].xyz[j] = LittleFloat(verts[i].xyz[j]);
-			points[i].normal[j] = LittleFloat(verts[i].normal[j]);
-		}
-
-		for(j = 0; j < 2; j++)
-		{
-			points[i].st[j] = LittleFloat(verts[i].st[j]);
-			//points[i].lightmap[j] = LittleFloat(verts[i].lightmap[j]);
-		}
-		points[i].lightmap[0] = FatPackU(LittleFloat(verts[i].lightmap[0]), realLightmapNum);
-		points[i].lightmap[1] = FatPackV(LittleFloat(verts[i].lightmap[1]), realLightmapNum);
-
-		if (hdrVertColors)
-		{
-			color[0] = hdrVertColors[(ds->firstVert + i) * 3    ];
-			color[1] = hdrVertColors[(ds->firstVert + i) * 3 + 1];
-			color[2] = hdrVertColors[(ds->firstVert + i) * 3 + 2];
-		}
-		else
-		{
-			//hack: convert LDR vertex colors to HDR
-			if (r_hdr->integer)
-			{
-				color[0] = MAX(verts[i].color[0], 0.499f);
-				color[1] = MAX(verts[i].color[1], 0.499f);
-				color[2] = MAX(verts[i].color[2], 0.499f);
-			}
-			else
-			{
-				color[0] = verts[i].color[0];
-				color[1] = verts[i].color[1];
-				color[2] = verts[i].color[2];
-			}
-		}
-		color[3] = verts[i].color[3] / 255.0f;
-
-		R_ColorShiftLightingFloats( color, points[i].vertexColors, 1.0f / 255.0f );
-	}
+		LoadDrawVertToSrfVert(&points[i], &verts[i], realLightmapNum, hdrVertColors ? hdrVertColors + (ds->firstVert + i) * 3 : NULL, NULL);
 
 	// pre-tesseleate
 	R_SubdividePatchToGrid( grid, width, height, points );
@@ -965,49 +898,7 @@ static void ParseTriSurf( dsurface_t *ds, drawVert_t *verts, float *hdrVertColor
 	ClearBounds(surf->cullinfo.bounds[0], surf->cullinfo.bounds[1]);
 	verts += LittleLong(ds->firstVert);
 	for(i = 0; i < numVerts; i++)
-	{
-		vec4_t color;
-
-		for(j = 0; j < 3; j++)
-		{
-			cv->verts[i].xyz[j] = LittleFloat(verts[i].xyz[j]);
-			cv->verts[i].normal[j] = LittleFloat(verts[i].normal[j]);
-		}
-
-		AddPointToBounds( cv->verts[i].xyz, surf->cullinfo.bounds[0], surf->cullinfo.bounds[1] );
-
-		for(j = 0; j < 2; j++)
-		{
-			cv->verts[i].st[j] = LittleFloat(verts[i].st[j]);
-			cv->verts[i].lightmap[j] = LittleFloat(verts[i].lightmap[j]);
-		}
-
-		if (hdrVertColors)
-		{
-			color[0] = hdrVertColors[(ds->firstVert + i) * 3    ];
-			color[1] = hdrVertColors[(ds->firstVert + i) * 3 + 1];
-			color[2] = hdrVertColors[(ds->firstVert + i) * 3 + 2];
-		}
-		else
-		{
-			//hack: convert LDR vertex colors to HDR
-			if (r_hdr->integer)
-			{
-				color[0] = MAX(verts[i].color[0], 0.499f);
-				color[1] = MAX(verts[i].color[1], 0.499f);
-				color[2] = MAX(verts[i].color[2], 0.499f);
-			}
-			else
-			{
-				color[0] = verts[i].color[0];
-				color[1] = verts[i].color[1];
-				color[2] = verts[i].color[2];
-			}
-		}
-		color[3] = verts[i].color[3] / 255.0f;
-
-		R_ColorShiftLightingFloats( color, cv->verts[i].vertexColors, 1.0f / 255.0f );
-	}
+		LoadDrawVertToSrfVert(&cv->verts[i], &verts[i], -1, hdrVertColors ? hdrVertColors + (ds->firstVert + i) * 3 : NULL, surf->cullinfo.bounds);
 
 	// copy triangles
 	badTriangles = 0;
@@ -1037,7 +928,6 @@ static void ParseTriSurf( dsurface_t *ds, drawVert_t *verts, float *hdrVertColor
 		cv->numIndexes -= badTriangles * 3;
 	}
 
-#ifdef USE_VERT_TANGENT_SPACE
 	// Calculate tangent spaces
 	{
 		srfVert_t      *dv[3];
@@ -1051,7 +941,6 @@ static void ParseTriSurf( dsurface_t *ds, drawVert_t *verts, float *hdrVertColor
 			R_CalcTangentVectors(dv);
 		}
 	}
-#endif
 }
 
 /*
@@ -1847,16 +1736,14 @@ static int BSPSurfaceCompare(const void *a, const void *b)
 static void CopyVert(const srfVert_t * in, srfVert_t * out)
 {
 	VectorCopy(in->xyz,      out->xyz);
-#ifdef USE_VERT_TANGENT_SPACE
 	VectorCopy4(in->tangent, out->tangent);
-#endif
-	VectorCopy(in->normal,   out->normal);
-	VectorCopy(in->lightdir, out->lightdir);
+	VectorCopy4(in->normal,   out->normal);
+	VectorCopy4(in->lightdir, out->lightdir);
 
 	VectorCopy2(in->st,       out->st);
 	VectorCopy2(in->lightmap, out->lightmap);
 
-	VectorCopy4(in->vertexColors, out->vertexColors);
+	VectorCopy4(in->color,    out->color);
 }
 
 
@@ -2670,9 +2557,9 @@ static	void R_LoadFogs( lump_t *l, lump_t *brushesLump, lump_t *sidesLump ) {
 
 		out->parms = shader->fogParms;
 
-		out->colorInt = ColorBytes4 ( shader->fogParms.color[0] * tr.identityLight, 
-			                          shader->fogParms.color[1] * tr.identityLight, 
-			                          shader->fogParms.color[2] * tr.identityLight, 1.0 );
+		out->colorInt = ColorBytes4 ( shader->fogParms.color[0],
+			                          shader->fogParms.color[1],
+			                          shader->fogParms.color[2], 1.0 );
 
 		d = shader->fogParms.depthForOpaque < 1 ? 1 : shader->fogParms.depthForOpaque;
 		out->tcScale = 1.0f / ( d * 8 );
@@ -2754,29 +2641,47 @@ void R_LoadLightGrid( lump_t *l ) {
 
 		if (hdrLightGrid)
 		{
-#if defined(USE_OVERBRIGHT)
-			float lightScale = 1 << (r_mapOverBrightBits->integer - tr.overbrightBits);
-#else
-			float lightScale = 1.0f;
-#endif
-
 			//ri.Printf(PRINT_ALL, "found!\n");
 
 			if (size != sizeof(float) * 6 * numGridPoints)
-			{
 				ri.Error(ERR_DROP, "Bad size for %s (%i, expected %i)!", filename, size, (int)(sizeof(float)) * 6 * numGridPoints);
-			}
 
-			w->hdrLightGrid = ri.Hunk_Alloc(size, h_low);
+			w->lightGrid16 = ri.Hunk_Alloc(sizeof(w->lightGrid16) * 6 * numGridPoints, h_low);
 
 			for (i = 0; i < numGridPoints ; i++)
 			{
-				w->hdrLightGrid[i * 6    ] = hdrLightGrid[i * 6    ] * lightScale;
-				w->hdrLightGrid[i * 6 + 1] = hdrLightGrid[i * 6 + 1] * lightScale;
-				w->hdrLightGrid[i * 6 + 2] = hdrLightGrid[i * 6 + 2] * lightScale;
-				w->hdrLightGrid[i * 6 + 3] = hdrLightGrid[i * 6 + 3] * lightScale;
-				w->hdrLightGrid[i * 6 + 4] = hdrLightGrid[i * 6 + 4] * lightScale;
-				w->hdrLightGrid[i * 6 + 5] = hdrLightGrid[i * 6 + 5] * lightScale;
+				vec4_t c;
+
+				c[0] = hdrLightGrid[i * 6];
+				c[1] = hdrLightGrid[i * 6 + 1];
+				c[2] = hdrLightGrid[i * 6 + 2];
+				c[3] = 1.0f;
+
+				R_ColorShiftLightingFloats(c, c);
+				ColorToRGB16(c, &w->lightGrid16[i * 6]);
+
+				c[0] = hdrLightGrid[i * 6 + 3];
+				c[1] = hdrLightGrid[i * 6 + 4];
+				c[2] = hdrLightGrid[i * 6 + 5];
+				c[3] = 1.0f;
+
+				R_ColorShiftLightingFloats(c, c);
+				ColorToRGB16(c, &w->lightGrid16[i * 6 + 3]);
+			}
+		}
+		else if (0)
+		{
+			// promote 8-bit lightgrid to 16-bit
+			w->lightGrid16 = ri.Hunk_Alloc(sizeof(w->lightGrid16) * 6 * numGridPoints, h_low);
+
+			for (i = 0; i < numGridPoints; i++)
+			{
+				w->lightGrid16[i * 6]     = w->lightGridData[i * 8] * 257;
+				w->lightGrid16[i * 6 + 1] = w->lightGridData[i * 8 + 1] * 257;
+				w->lightGrid16[i * 6 + 2] = w->lightGridData[i * 8 + 2] * 257;
+				w->lightGrid16[i * 6 + 3] = w->lightGridData[i * 8 + 3] * 257;
+				w->lightGrid16[i * 6 + 4] = w->lightGridData[i * 8 + 4] * 257;
+				w->lightGrid16[i * 6 + 5] = w->lightGridData[i * 8 + 5] * 257;
 			}
 		}
 
@@ -3194,7 +3099,14 @@ void R_CalcVertexLightDirs( void )
 			case SF_GRID:
 			case SF_TRIANGLES:
 				for(i = 0; i < bspSurf->numVerts; i++)
-					R_LightDirForPoint( bspSurf->verts[i].xyz, bspSurf->verts[i].lightdir, bspSurf->verts[i].normal, &s_worldData );
+				{
+					vec3_t lightDir;
+					vec3_t normal;
+
+					R_VaoUnpackNormal(normal, bspSurf->verts[i].normal);
+					R_LightDirForPoint( bspSurf->verts[i].xyz, lightDir, normal, &s_worldData );
+					R_VaoPackNormal(bspSurf->verts[i].lightdir, lightDir);
+				}
 
 				break;
 
@@ -3226,7 +3138,6 @@ void RE_LoadWorldMap( const char *name ) {
 	}
 
 	// set default map light scale
-	tr.mapLightScale  = 1.0f;
 	tr.sunShadowScale = 0.5f;
 
 	// set default sun direction to be used if it isn't
diff --git a/src/renderergl2/tr_curve.c b/src/renderergl2/tr_curve.c
index 68573e1..c8b6c04 100644
--- a/src/renderergl2/tr_curve.c
+++ b/src/renderergl2/tr_curve.c
@@ -55,10 +55,10 @@ static void LerpDrawVert( srfVert_t *a, srfVert_t *b, srfVert_t *out ) {
 	out->lightmap[0] = 0.5f * (a->lightmap[0] + b->lightmap[0]);
 	out->lightmap[1] = 0.5f * (a->lightmap[1] + b->lightmap[1]);
 
-	out->vertexColors[0] = 0.5f * (a->vertexColors[0] + b->vertexColors[0]);
-	out->vertexColors[1] = 0.5f * (a->vertexColors[1] + b->vertexColors[1]);
-	out->vertexColors[2] = 0.5f * (a->vertexColors[2] + b->vertexColors[2]);
-	out->vertexColors[3] = 0.5f * (a->vertexColors[3] + b->vertexColors[3]);
+	out->color[0] = ((int)a->color[0] + (int)b->color[0]) >> 1;
+	out->color[1] = ((int)a->color[1] + (int)b->color[1]) >> 1;
+	out->color[2] = ((int)a->color[2] + (int)b->color[2]) >> 1;
+	out->color[3] = ((int)a->color[3] + (int)b->color[3]) >> 1;
 }
 
 /*
@@ -208,12 +208,15 @@ static	int	neighbors[8][2] = {
 			//if ( count == 0 ) {
 			//	printf("bad normal\n");
 			//}
-			VectorNormalize2( sum, dv->normal );
+			{
+				vec3_t fNormal;
+				VectorNormalize2(sum, fNormal);
+				R_VaoPackNormal(dv->normal, fNormal);
+			}
 		}
 	}
 }
 
-#ifdef USE_VERT_TANGENT_SPACE
 static void MakeMeshTangentVectors(int width, int height, srfVert_t ctrl[MAX_GRID_SIZE][MAX_GRID_SIZE], int numIndexes,
 								   glIndex_t indexes[(MAX_GRID_SIZE-1)*(MAX_GRID_SIZE-1)*2*3])
 {
@@ -252,7 +255,6 @@ static void MakeMeshTangentVectors(int width, int height, srfVert_t ctrl[MAX_GRI
 		}
 	}
 }
-#endif
 
 
 static int MakeMeshIndexes(int width, int height, glIndex_t indexes[(MAX_GRID_SIZE-1)*(MAX_GRID_SIZE-1)*2*3])
@@ -429,7 +431,7 @@ void R_CreateSurfaceGridMesh(srfBspSurface_t *grid, int width, int height,
 R_FreeSurfaceGridMesh
 =================
 */
-void R_FreeSurfaceGridMeshData( srfBspSurface_t *grid ) {
+static void R_FreeSurfaceGridMeshData( srfBspSurface_t *grid ) {
 	ri.Free(grid->widthLodError);
 	ri.Free(grid->heightLodError);
 	ri.Free(grid->indexes);
@@ -612,9 +614,7 @@ void R_SubdividePatchToGrid( srfBspSurface_t *grid, int width, int height,
 
 	// calculate normals
 	MakeMeshNormals( width, height, ctrl );
-#ifdef USE_VERT_TANGENT_SPACE
 	MakeMeshTangentVectors(width, height, ctrl, numIndexes, indexes);
-#endif
 
 	R_CreateSurfaceGridMesh(grid, width, height, ctrl, errorTable, numIndexes, indexes);
 }
@@ -667,9 +667,7 @@ void R_GridInsertColumn( srfBspSurface_t *grid, int column, int row, vec3_t poin
 
 	// calculate normals
 	MakeMeshNormals( width, height, ctrl );
-#ifdef USE_VERT_TANGENT_SPACE
 	MakeMeshTangentVectors(width, height, ctrl, numIndexes, indexes);
-#endif
 
 	VectorCopy(grid->lodOrigin, lodOrigin);
 	lodRadius = grid->lodRadius;
@@ -729,9 +727,7 @@ void R_GridInsertRow( srfBspSurface_t *grid, int row, int column, vec3_t point,
 
 	// calculate normals
 	MakeMeshNormals( width, height, ctrl );
-#ifdef USE_VERT_TANGENT_SPACE
 	MakeMeshTangentVectors(width, height, ctrl, numIndexes, indexes);
-#endif
 
 	VectorCopy(grid->lodOrigin, lodOrigin);
 	lodRadius = grid->lodRadius;
diff --git a/src/renderergl2/tr_dsa.c b/src/renderergl2/tr_dsa.c
index f738a5d..8fde841 100644
--- a/src/renderergl2/tr_dsa.c
+++ b/src/renderergl2/tr_dsa.c
@@ -113,11 +113,11 @@ GLvoid APIENTRY GLDSA_TextureSubImage2DEXT(GLuint texture, GLenum target, GLint
 	qglTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
 }
 
-GLvoid APIENTRY GLDSA_CopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat,
-	GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
+GLvoid APIENTRY GLDSA_CopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset,
+	GLint x, GLint y, GLsizei width, GLsizei height)
 {
 	GL_BindMultiTexture(glDsaState.texunit, target, texture);
-	qglCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
+	qglCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
 }
 
 GLvoid APIENTRY  GLDSA_CompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat,
diff --git a/src/renderergl2/tr_dsa.h b/src/renderergl2/tr_dsa.h
index 44f3230..84e35f5 100644
--- a/src/renderergl2/tr_dsa.h
+++ b/src/renderergl2/tr_dsa.h
@@ -33,8 +33,8 @@ GLvoid APIENTRY GLDSA_TextureImage2DEXT(GLuint texture, GLenum target, GLint lev
 	GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
 GLvoid APIENTRY GLDSA_TextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset,
 	GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
-GLvoid APIENTRY GLDSA_CopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat,
-	GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
+GLvoid APIENTRY GLDSA_CopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset,
+	GLint x, GLint y, GLsizei width, GLsizei height);
 GLvoid APIENTRY GLDSA_CompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat,
 	GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
 GLvoid APIENTRY GLDSA_CompressedTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level,
diff --git a/src/renderergl2/tr_extensions.c b/src/renderergl2/tr_extensions.c
index d205560..00bee2c 100644
--- a/src/renderergl2/tr_extensions.c
+++ b/src/renderergl2/tr_extensions.c
@@ -43,15 +43,6 @@ QGL_ARB_vertex_array_object_PROCS;
 QGL_EXT_direct_state_access_PROCS;
 #undef GLE
 
-static qboolean GLimp_HaveExtension(const char *ext)
-{
-	const char *ptr = Q_stristr( glConfig.extensions_string, ext );
-	if (ptr == NULL)
-		return qfalse;
-	ptr += strlen(ext);
-	return ((*ptr == ' ') || (*ptr == '\0'));  // verify it's complete string.
-}
-
 void GLimp_InitExtraExtensions()
 {
 	char *extension;
@@ -63,6 +54,11 @@ void GLimp_InitExtraExtensions()
 		ri.Error(ERR_FATAL, "OpenGL 2.0 required!");
 	ri.Printf(PRINT_ALL, "...using OpenGL %s\n", glConfig.version_string);
 
+	// Check if we need Intel graphics specific fixes.
+	glRefConfig.intelGraphics = qfalse;
+	if (strstr((char *)qglGetString(GL_RENDERER), "Intel"))
+		glRefConfig.intelGraphics = qtrue;
+
 	// set DSA fallbacks
 #define GLE(ret, name, ...) qgl##name = GLDSA_##name;
 	QGL_EXT_direct_state_access_PROCS;
@@ -107,7 +103,7 @@ void GLimp_InitExtraExtensions()
 
 	// GL_NVX_gpu_memory_info
 	extension = "GL_NVX_gpu_memory_info";
-	if( GLimp_HaveExtension( extension ) )
+	if( SDL_GL_ExtensionSupported( extension ) )
 	{
 		glRefConfig.memInfo = MI_NVX;
 
@@ -120,7 +116,7 @@ void GLimp_InitExtraExtensions()
 
 	// GL_ATI_meminfo
 	extension = "GL_ATI_meminfo";
-	if( GLimp_HaveExtension( extension ) )
+	if( SDL_GL_ExtensionSupported( extension ) )
 	{
 		if (glRefConfig.memInfo == MI_NONE)
 		{
@@ -138,24 +134,10 @@ void GLimp_InitExtraExtensions()
 		ri.Printf(PRINT_ALL, result[2], extension);
 	}
 
-	// GL_ARB_texture_non_power_of_two
-	extension = "GL_ARB_texture_non_power_of_two";
-	glRefConfig.textureNonPowerOfTwo = qfalse;
-	if( GLimp_HaveExtension( extension ) )
-	{
-		glRefConfig.textureNonPowerOfTwo = qtrue; // !!r_ext_texture_non_power_of_two->integer
-
-		ri.Printf(PRINT_ALL, result[glRefConfig.textureNonPowerOfTwo], extension);
-	}
-	else
-	{
-		ri.Printf(PRINT_ALL, result[2], extension);
-	}
-
 	// GL_ARB_texture_float
 	extension = "GL_ARB_texture_float";
 	glRefConfig.textureFloat = qfalse;
-	if( GLimp_HaveExtension( extension ) )
+	if( SDL_GL_ExtensionSupported( extension ) )
 	{
 		glRefConfig.textureFloat = !!r_ext_texture_float->integer;
 
@@ -166,29 +148,15 @@ void GLimp_InitExtraExtensions()
 		ri.Printf(PRINT_ALL, result[2], extension);
 	}
 
-	// GL_ARB_half_float_pixel
-	extension = "GL_ARB_half_float_pixel";
-	glRefConfig.halfFloatPixel = qfalse;
-	if( GLimp_HaveExtension( extension ) )
-	{
-		glRefConfig.halfFloatPixel = !!r_arb_half_float_pixel->integer;
-
-		ri.Printf(PRINT_ALL, result[glRefConfig.halfFloatPixel], extension);
-	}
-	else
-	{
-		ri.Printf(PRINT_ALL, result[2], extension);
-	}
-
 	// GL_EXT_framebuffer_object
 	extension = "GL_EXT_framebuffer_object";
 	glRefConfig.framebufferObject = qfalse;
-	if( GLimp_HaveExtension( extension ) )
+	if( SDL_GL_ExtensionSupported( extension ) )
 	{
 		glRefConfig.framebufferObject = !!r_ext_framebuffer_object->integer;
 
-		glGetIntegerv(GL_MAX_RENDERBUFFER_SIZE_EXT, &glRefConfig.maxRenderbufferSize);
-		glGetIntegerv(GL_MAX_COLOR_ATTACHMENTS_EXT, &glRefConfig.maxColorAttachments);
+		qglGetIntegerv(GL_MAX_RENDERBUFFER_SIZE_EXT, &glRefConfig.maxRenderbufferSize);
+		qglGetIntegerv(GL_MAX_COLOR_ATTACHMENTS_EXT, &glRefConfig.maxColorAttachments);
 
 		QGL_EXT_framebuffer_object_PROCS;
 
@@ -202,7 +170,7 @@ void GLimp_InitExtraExtensions()
 	// GL_EXT_framebuffer_blit
 	extension = "GL_EXT_framebuffer_blit";
 	glRefConfig.framebufferBlit = qfalse;
-	if (GLimp_HaveExtension(extension))
+	if (SDL_GL_ExtensionSupported(extension))
 	{
 		glRefConfig.framebufferBlit = qtrue;
 
@@ -218,7 +186,7 @@ void GLimp_InitExtraExtensions()
 	// GL_EXT_framebuffer_multisample
 	extension = "GL_EXT_framebuffer_multisample";
 	glRefConfig.framebufferMultisample = qfalse;
-	if (GLimp_HaveExtension(extension))
+	if (SDL_GL_ExtensionSupported(extension))
 	{
 		glRefConfig.framebufferMultisample = qtrue;
 
@@ -235,7 +203,7 @@ void GLimp_InitExtraExtensions()
 
 	// GL_ARB_texture_compression_rgtc
 	extension = "GL_ARB_texture_compression_rgtc";
-	if (GLimp_HaveExtension(extension))
+	if (SDL_GL_ExtensionSupported(extension))
 	{
 		qboolean useRgtc = r_ext_compressed_textures->integer >= 1;
 
@@ -253,7 +221,7 @@ void GLimp_InitExtraExtensions()
 
 	// GL_ARB_texture_compression_bptc
 	extension = "GL_ARB_texture_compression_bptc";
-	if (GLimp_HaveExtension(extension))
+	if (SDL_GL_ExtensionSupported(extension))
 	{
 		qboolean useBptc = r_ext_compressed_textures->integer >= 2;
 
@@ -270,7 +238,7 @@ void GLimp_InitExtraExtensions()
 	// GL_ARB_depth_clamp
 	extension = "GL_ARB_depth_clamp";
 	glRefConfig.depthClamp = qfalse;
-	if( GLimp_HaveExtension( extension ) )
+	if( SDL_GL_ExtensionSupported( extension ) )
 	{
 		glRefConfig.depthClamp = qtrue;
 
@@ -284,7 +252,7 @@ void GLimp_InitExtraExtensions()
 	// GL_ARB_seamless_cube_map
 	extension = "GL_ARB_seamless_cube_map";
 	glRefConfig.seamlessCubeMap = qfalse;
-	if( GLimp_HaveExtension( extension ) )
+	if( SDL_GL_ExtensionSupported( extension ) )
 	{
 		glRefConfig.seamlessCubeMap = !!r_arb_seamless_cube_map->integer;
 
@@ -295,30 +263,10 @@ void GLimp_InitExtraExtensions()
 		ri.Printf(PRINT_ALL, result[2], extension);
 	}
 
-	// GL_ARB_vertex_type_2_10_10_10_rev
-	extension = "GL_ARB_vertex_type_2_10_10_10_rev";
-	glRefConfig.packedNormalDataType = GL_BYTE;
-	if( GLimp_HaveExtension( extension ) )
-	{
-		qboolean useExt = !!r_arb_vertex_type_2_10_10_10_rev->integer;
-
-		if (useExt)
-			glRefConfig.packedNormalDataType = GL_INT_2_10_10_10_REV;
-
-		ri.Printf(PRINT_ALL, result[useExt], extension);
-	}
-	else
-	{
-		ri.Printf(PRINT_ALL, result[2], extension);
-	}
-
-	// use float lightmaps?
-	glRefConfig.floatLightmap = (glRefConfig.textureFloat && glRefConfig.halfFloatPixel && r_floatLightmap->integer && r_hdr->integer);
-
 	// GL_ARB_vertex_array_object
 	extension = "GL_ARB_vertex_array_object";
 	glRefConfig.vertexArrayObject = qfalse;
-	if( GLimp_HaveExtension( extension ) )
+	if( SDL_GL_ExtensionSupported( extension ) )
 	{
 		glRefConfig.vertexArrayObject = !!r_arb_vertex_array_object->integer;
 
@@ -331,35 +279,10 @@ void GLimp_InitExtraExtensions()
 		ri.Printf(PRINT_ALL, result[2], extension);
 	}
 
-	// GL_ARB_half_float_vertex
-	extension = "GL_ARB_half_float_vertex";
-	glRefConfig.packedTexcoordDataType = GL_FLOAT;
-	glRefConfig.packedTexcoordDataSize = sizeof(float) * 2;
-	glRefConfig.packedColorDataType    = GL_FLOAT;
-	glRefConfig.packedColorDataSize    = sizeof(float) * 4;
-	if( GLimp_HaveExtension( extension ) )
-	{
-		qboolean useExt = !!r_arb_half_float_vertex->integer;
-
-		if (useExt)
-		{
-			glRefConfig.packedTexcoordDataType = GL_HALF_FLOAT;
-			glRefConfig.packedTexcoordDataSize = sizeof(uint16_t) * 2;
-			glRefConfig.packedColorDataType    = GL_HALF_FLOAT;
-			glRefConfig.packedColorDataSize    = sizeof(uint16_t) * 4;
-		}
-
-		ri.Printf(PRINT_ALL, result[useExt], extension);
-	}
-	else
-	{
-		ri.Printf(PRINT_ALL, result[2], extension);
-	}
-
 	// GL_EXT_direct_state_access
 	extension = "GL_EXT_direct_state_access";
 	glRefConfig.directStateAccess = qfalse;
-	if (GLimp_HaveExtension(extension))
+	if (SDL_GL_ExtensionSupported(extension))
 	{
 		glRefConfig.directStateAccess = !!r_ext_direct_state_access->integer;
 
diff --git a/src/renderergl2/tr_extramath.c b/src/renderergl2/tr_extramath.c
index fc0a21a..4cf5ef3 100644
--- a/src/renderergl2/tr_extramath.c
+++ b/src/renderergl2/tr_extramath.c
@@ -201,7 +201,7 @@ int NextPowerOfTwo(int in)
 
 union f32_u {
 	float f;
-	uint32_t i;
+	uint32_t ui;
 	struct {
 		unsigned int fraction:23;
 		unsigned int exponent:8;
@@ -210,7 +210,7 @@ union f32_u {
 };
 
 union f16_u {
-	uint16_t i;
+	uint16_t ui;
 	struct {
 		unsigned int fraction:10;
 		unsigned int exponent:5;
@@ -229,5 +229,19 @@ uint16_t FloatToHalf(float in)
 	f16.pack.fraction = f32.pack.fraction >> 13;
 	f16.pack.sign     = f32.pack.sign;
 
-	return f16.i;
+	return f16.ui;
+}
+
+float HalfToFloat(uint16_t in)
+{
+	union f32_u f32;
+	union f16_u f16;
+
+	f16.ui = in;
+
+	f32.pack.exponent = (int)(f16.pack.exponent) + 112;
+	f32.pack.fraction = f16.pack.fraction << 13;
+	f32.pack.sign = f16.pack.sign;
+
+	return f32.f;
 }
diff --git a/src/renderergl2/tr_extramath.h b/src/renderergl2/tr_extramath.h
index 131d9f6..01c3050 100644
--- a/src/renderergl2/tr_extramath.h
+++ b/src/renderergl2/tr_extramath.h
@@ -98,5 +98,6 @@ void BoundingSphereOfSpheres(vec3_t origin1, float radius1, vec3_t origin2, floa
 
 int NextPowerOfTwo(int in);
 unsigned short FloatToHalf(float in);
+float HalfToFloat(unsigned short in);
 
 #endif
diff --git a/src/renderergl2/tr_fbo.c b/src/renderergl2/tr_fbo.c
index 41cfdd7..6b7ab01 100644
--- a/src/renderergl2/tr_fbo.c
+++ b/src/renderergl2/tr_fbo.c
@@ -230,6 +230,12 @@ FBO_Bind
 */
 void FBO_Bind(FBO_t * fbo)
 {
+	if (!glRefConfig.framebufferObject)
+	{
+		ri.Printf(PRINT_WARNING, "FBO_Bind() called without framebuffers enabled!\n");
+		return;
+	}
+
 	if (glState.currentFBO == fbo)
 		return;
 		
@@ -265,7 +271,7 @@ void FBO_Init(void)
 	R_IssuePendingRenderCommands();
 
 	hdrFormat = GL_RGBA8;
-	if (r_hdr->integer && glRefConfig.framebufferObject && glRefConfig.textureFloat)
+	if (r_hdr->integer && glRefConfig.textureFloat)
 		hdrFormat = GL_RGBA16F_ARB;
 
 	if (glRefConfig.framebufferMultisample)
diff --git a/src/renderergl2/tr_flares.c b/src/renderergl2/tr_flares.c
index 4b0e792..3370066 100644
--- a/src/renderergl2/tr_flares.c
+++ b/src/renderergl2/tr_flares.c
@@ -396,51 +396,51 @@ void RB_RenderFlare( flare_t *f ) {
 			return;
 	}
 
-	iColor[0] = color[0] * fogFactors[0];
-	iColor[1] = color[1] * fogFactors[1];
-	iColor[2] = color[2] * fogFactors[2];
+	iColor[0] = color[0] * fogFactors[0] * 257;
+	iColor[1] = color[1] * fogFactors[1] * 257;
+	iColor[2] = color[2] * fogFactors[2] * 257;
 	
 	RB_BeginSurface( tr.flareShader, f->fogNum, 0 );
 
 	// FIXME: use quadstamp?
 	tess.xyz[tess.numVertexes][0] = f->windowX - size;
 	tess.xyz[tess.numVertexes][1] = f->windowY - size;
-	tess.texCoords[tess.numVertexes][0][0] = 0;
-	tess.texCoords[tess.numVertexes][0][1] = 0;
-	tess.vertexColors[tess.numVertexes][0] = iColor[0] / 255.0f;
-	tess.vertexColors[tess.numVertexes][1] = iColor[1] / 255.0f;
-	tess.vertexColors[tess.numVertexes][2] = iColor[2] / 255.0f;
-	tess.vertexColors[tess.numVertexes][3] = 1.0f;
+	tess.texCoords[tess.numVertexes][0] = 0;
+	tess.texCoords[tess.numVertexes][1] = 0;
+	tess.color[tess.numVertexes][0] = iColor[0];
+	tess.color[tess.numVertexes][1] = iColor[1];
+	tess.color[tess.numVertexes][2] = iColor[2];
+	tess.color[tess.numVertexes][3] = 65535;
 	tess.numVertexes++;
 
 	tess.xyz[tess.numVertexes][0] = f->windowX - size;
 	tess.xyz[tess.numVertexes][1] = f->windowY + size;
-	tess.texCoords[tess.numVertexes][0][0] = 0;
-	tess.texCoords[tess.numVertexes][0][1] = 1;
-	tess.vertexColors[tess.numVertexes][0] = iColor[0] / 255.0f;
-	tess.vertexColors[tess.numVertexes][1] = iColor[1] / 255.0f;
-	tess.vertexColors[tess.numVertexes][2] = iColor[2] / 255.0f;
-	tess.vertexColors[tess.numVertexes][3] = 1.0f;
+	tess.texCoords[tess.numVertexes][0] = 0;
+	tess.texCoords[tess.numVertexes][1] = 1;
+	tess.color[tess.numVertexes][0] = iColor[0];
+	tess.color[tess.numVertexes][1] = iColor[1];
+	tess.color[tess.numVertexes][2] = iColor[2];
+	tess.color[tess.numVertexes][3] = 65535;
 	tess.numVertexes++;
 
 	tess.xyz[tess.numVertexes][0] = f->windowX + size;
 	tess.xyz[tess.numVertexes][1] = f->windowY + size;
-	tess.texCoords[tess.numVertexes][0][0] = 1;
-	tess.texCoords[tess.numVertexes][0][1] = 1;
-	tess.vertexColors[tess.numVertexes][0] = iColor[0] / 255.0f;
-	tess.vertexColors[tess.numVertexes][1] = iColor[1] / 255.0f;
-	tess.vertexColors[tess.numVertexes][2] = iColor[2] / 255.0f;
-	tess.vertexColors[tess.numVertexes][3] = 1.0f;
+	tess.texCoords[tess.numVertexes][0] = 1;
+	tess.texCoords[tess.numVertexes][1] = 1;
+	tess.color[tess.numVertexes][0] = iColor[0];
+	tess.color[tess.numVertexes][1] = iColor[1];
+	tess.color[tess.numVertexes][2] = iColor[2];
+	tess.color[tess.numVertexes][3] = 65535;
 	tess.numVertexes++;
 
 	tess.xyz[tess.numVertexes][0] = f->windowX + size;
 	tess.xyz[tess.numVertexes][1] = f->windowY - size;
-	tess.texCoords[tess.numVertexes][0][0] = 1;
-	tess.texCoords[tess.numVertexes][0][1] = 0;
-	tess.vertexColors[tess.numVertexes][0] = iColor[0] / 255.0f;
-	tess.vertexColors[tess.numVertexes][1] = iColor[1] / 255.0f;
-	tess.vertexColors[tess.numVertexes][2] = iColor[2] / 255.0f;
-	tess.vertexColors[tess.numVertexes][3] = 1.0f;
+	tess.texCoords[tess.numVertexes][0] = 1;
+	tess.texCoords[tess.numVertexes][1] = 0;
+	tess.color[tess.numVertexes][0] = iColor[0];
+	tess.color[tess.numVertexes][1] = iColor[1];
+	tess.color[tess.numVertexes][2] = iColor[2];
+	tess.color[tess.numVertexes][3] = 65535;
 	tess.numVertexes++;
 
 	tess.indexes[tess.numIndexes++] = 0;
diff --git a/src/renderergl2/tr_glsl.c b/src/renderergl2/tr_glsl.c
index f934942..84f36ec 100644
--- a/src/renderergl2/tr_glsl.c
+++ b/src/renderergl2/tr_glsl.c
@@ -1028,9 +1028,6 @@ void GLSL_InitGPUShaders(void)
 		if (glRefConfig.swizzleNormalmap)
 			Q_strcat(extradefines, 1024, "#define SWIZZLE_NORMALMAP\n");
 
-		if (r_hdr->integer && !glRefConfig.floatLightmap)
-			Q_strcat(extradefines, 1024, "#define RGBM_LIGHTMAP\n");
-
 		if (lightType)
 		{
 			Q_strcat(extradefines, 1024, "#define USE_LIGHT\n");
@@ -1061,10 +1058,7 @@ void GLSL_InitGPUShaders(void)
 			{
 				Q_strcat(extradefines, 1024, "#define USE_NORMALMAP\n");
 
-#ifdef USE_VERT_TANGENT_SPACE
-				Q_strcat(extradefines, 1024, "#define USE_VERT_TANGENT_SPACE\n");
 				attribs |= ATTR_TANGENT;
-#endif
 
 				if ((i & LIGHTDEF_USE_PARALLAXMAP) && !(i & LIGHTDEF_ENTITY) && r_parallaxMapping->integer)
 				{
@@ -1119,12 +1113,10 @@ void GLSL_InitGPUShaders(void)
 			Q_strcat(extradefines, 1024, "#define USE_VERTEX_ANIMATION\n#define USE_MODELMATRIX\n");
 			attribs |= ATTR_POSITION2 | ATTR_NORMAL2;
 
-#ifdef USE_VERT_TANGENT_SPACE
 			if (r_normalMapping->integer)
 			{
 				attribs |= ATTR_TANGENT2;
 			}
-#endif
 		}
 
 		if (!GLSL_InitGPUShader(&tr.lightallShader[i], "lightall", attribs, qtrue, extradefines, qtrue, fallbackShader_lightall_vp, fallbackShader_lightall_fp))
diff --git a/src/renderergl2/tr_image.c b/src/renderergl2/tr_image.c
index a1a9e29..1d9fb7b 100644
--- a/src/renderergl2/tr_image.c
+++ b/src/renderergl2/tr_image.c
@@ -151,12 +151,12 @@ void R_ImageList_f( void ) {
 	int i;
 	int estTotalSize = 0;
 
-	ri.Printf(PRINT_ALL, "\n      -w-- -h-- type  -size- --name-------\n");
+	ri.Printf(PRINT_ALL, "\n      -w-- -h-- -type-- -size- --name-------\n");
 
 	for ( i = 0 ; i < tr.numImages ; i++ )
 	{
 		image_t *image = tr.images[i];
-		char *format = "???? ";
+		char *format = "????   ";
 		char *sizeSuffix;
 		int estSize;
 		int displaySize;
@@ -166,95 +166,121 @@ void R_ImageList_f( void ) {
 		switch(image->internalFormat)
 		{
 			case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:
-				format = "sDXT1";
+				format = "sDXT1  ";
 				// 64 bits per 16 pixels, so 4 bits per pixel
 				estSize /= 2;
 				break;
 			case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:
-				format = "sDXT5";
+				format = "sDXT5  ";
 				// 128 bits per 16 pixels, so 1 byte per pixel
 				break;
 			case GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB:
-				format = "sBPTC";
+				format = "sBPTC  ";
 				// 128 bits per 16 pixels, so 1 byte per pixel
 				break;
 			case GL_COMPRESSED_RG_RGTC2:
-				format = "RGTC2";
+				format = "RGTC2  ";
 				// 128 bits per 16 pixels, so 1 byte per pixel
 				break;
 			case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
-				format = "DXT1 ";
+				format = "DXT1   ";
 				// 64 bits per 16 pixels, so 4 bits per pixel
 				estSize /= 2;
 				break;
 			case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
-				format = "DXT1a";
+				format = "DXT1a  ";
 				// 64 bits per 16 pixels, so 4 bits per pixel
 				estSize /= 2;
 				break;
 			case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
-				format = "DXT5 ";
+				format = "DXT5   ";
 				// 128 bits per 16 pixels, so 1 byte per pixel
 				break;
 			case GL_COMPRESSED_RGBA_BPTC_UNORM_ARB:
-				format = "BPTC ";
+				format = "BPTC   ";
 				// 128 bits per 16 pixels, so 1 byte per pixel
 				break;
 			case GL_RGB4_S3TC:
-				format = "S3TC ";
+				format = "S3TC   ";
 				// same as DXT1?
 				estSize /= 2;
 				break;
+			case GL_RGBA16F:
+				format = "RGBA16F";
+				// 8 bytes per pixel
+				estSize *= 8;
+				break;
+			case GL_RGBA16:
+				format = "RGBA16 ";
+				// 8 bytes per pixel
+				estSize *= 8;
+				break;
 			case GL_RGBA4:
 			case GL_RGBA8:
 			case GL_RGBA:
-				format = "RGBA ";
+				format = "RGBA   ";
 				// 4 bytes per pixel
 				estSize *= 4;
 				break;
 			case GL_LUMINANCE8:
 			case GL_LUMINANCE16:
 			case GL_LUMINANCE:
-				format = "L    ";
+				format = "L      ";
 				// 1 byte per pixel?
 				break;
 			case GL_RGB5:
 			case GL_RGB8:
 			case GL_RGB:
-				format = "RGB  ";
+				format = "RGB    ";
 				// 3 bytes per pixel?
 				estSize *= 3;
 				break;
 			case GL_LUMINANCE8_ALPHA8:
 			case GL_LUMINANCE16_ALPHA16:
 			case GL_LUMINANCE_ALPHA:
-				format = "LA   ";
+				format = "LA     ";
 				// 2 bytes per pixel?
 				estSize *= 2;
 				break;
 			case GL_SRGB_EXT:
 			case GL_SRGB8_EXT:
-				format = "sRGB ";
+				format = "sRGB   ";
 				// 3 bytes per pixel?
 				estSize *= 3;
 				break;
 			case GL_SRGB_ALPHA_EXT:
 			case GL_SRGB8_ALPHA8_EXT:
-				format = "sRGBA";
+				format = "sRGBA  ";
 				// 4 bytes per pixel?
 				estSize *= 4;
 				break;
 			case GL_SLUMINANCE_EXT:
 			case GL_SLUMINANCE8_EXT:
-				format = "sL   ";
+				format = "sL     ";
 				// 1 byte per pixel?
 				break;
 			case GL_SLUMINANCE_ALPHA_EXT:
 			case GL_SLUMINANCE8_ALPHA8_EXT:
-				format = "sLA  ";
+				format = "sLA    ";
 				// 2 byte per pixel?
 				estSize *= 2;
 				break;
+			case GL_DEPTH_COMPONENT16:
+				format = "Depth16";
+				// 2 bytes per pixel
+				estSize *= 2;
+				break;
+			case GL_DEPTH_COMPONENT24:
+				format = "Depth24";
+				// 3 bytes per pixel
+				estSize *= 3;
+				break;
+			case GL_DEPTH_COMPONENT:
+			case GL_DEPTH_COMPONENT32:
+				format = "Depth32";
+				// 4 bytes per pixel
+				estSize *= 4;
+				break;
 		}
 
 		// mipmap adds about 50%
@@ -477,11 +503,11 @@ static void RGBAtoNormal(const byte *in, byte *out, int width, int height, qbool
 
 					if (clampToEdge)
 					{
-						src_x = CLAMP(src_x, 0, height - 1);
+						src_x = CLAMP(src_x, 0, width - 1);
 					}
 					else
 					{
-						src_x = (src_x + height) % height;
+						src_x = (src_x + width) % width;
 					}
 
 					s[i++] = *(out + (src_y * width + src_x) * 4 + 3);
@@ -1462,12 +1488,12 @@ static qboolean RawImage_ScaleToPower2( byte **data, int *inout_width, int *inou
 	qboolean picmip = flags & IMGFLAG_PICMIP;
 	qboolean mipmap = flags & IMGFLAG_MIPMAP;
 	qboolean clampToEdge = flags & IMGFLAG_CLAMPTOEDGE;
-	qboolean notScaled;
+	qboolean scaled;
 
 	//
 	// convert to exact power of 2 sizes
 	//
-	if (glRefConfig.textureNonPowerOfTwo && !mipmap)
+	if (!mipmap)
 	{
 		scaled_width = width;
 		scaled_height = height;
@@ -1573,7 +1599,7 @@ static qboolean RawImage_ScaleToPower2( byte **data, int *inout_width, int *inou
 	scaled_width  = MAX(1, scaled_width);
 	scaled_height = MAX(1, scaled_height);
 
-	notScaled = (width == scaled_width) && (height == scaled_height);
+	scaled = (width != scaled_width) || (height != scaled_height);
 
 	//
 	// rescale texture to new size using existing mipmap functions
@@ -1595,7 +1621,7 @@ static qboolean RawImage_ScaleToPower2( byte **data, int *inout_width, int *inou
 	*inout_width  = width;
 	*inout_height = height;
 
-	return notScaled;
+	return scaled;
 }
 
 
@@ -1629,7 +1655,7 @@ static GLenum RawImage_GetFormat(const byte *data, int numPixels, GLenum picForm
 
 	if(normalmap)
 	{
-		if ((type == IMGTYPE_NORMALHEIGHT) && RawImage_HasAlpha(data, numPixels))
+		if ((type == IMGTYPE_NORMALHEIGHT) && RawImage_HasAlpha(data, numPixels) && r_parallaxMapping->integer)
 		{
 			if (!forceNoCompression && glRefConfig.textureCompression & TCR_BPTC)
 			{
@@ -1819,9 +1845,9 @@ static void CompressMonoBlock(byte outdata[8], const byte indata[16])
 	}
 }
 
-static void RawImage_UploadToRgtc2Texture(GLuint texture, byte *data, int width, int height, int mip)
+static void RawImage_UploadToRgtc2Texture(GLuint texture, int miplevel, int x, int y, int width, int height, byte *data)
 {
-	int wBlocks, hBlocks, y, x, size;
+	int wBlocks, hBlocks, iy, ix, size;
 	byte *compressedData, *p;
 
 	wBlocks = (width + 3) / 4;
@@ -1829,16 +1855,16 @@ static void RawImage_UploadToRgtc2Texture(GLuint texture, byte *data, int width,
 	size = wBlocks * hBlocks * 16;
 
 	p = compressedData = ri.Hunk_AllocateTempMemory(size);
-	for (y = 0; y < height; y += 4)
+	for (iy = 0; iy < height; iy += 4)
 	{
-		int oh = MIN(4, height - y);
+		int oh = MIN(4, height - iy);
 
-		for (x = 0; x < width; x += 4)
+		for (ix = 0; ix < width; ix += 4)
 		{
 			byte workingData[16];
 			int component;
 
-			int ow = MIN(4, width - x);
+			int ow = MIN(4, width - ix);
 
 			for (component = 0; component < 2; component++)
 			{
@@ -1846,7 +1872,7 @@ static void RawImage_UploadToRgtc2Texture(GLuint texture, byte *data, int width,
 
 				for (oy = 0; oy < oh; oy++)
 					for (ox = 0; ox < ow; ox++)
-						workingData[oy * 4 + ox] = data[((y + oy) * width + x + ox) * 4 + component];
+						workingData[oy * 4 + ox] = data[((iy + oy) * width + ix + ox) * 4 + component];
 
 				// dupe data to fill
 				for (oy = 0; oy < 4; oy++)
@@ -1859,7 +1885,8 @@ static void RawImage_UploadToRgtc2Texture(GLuint texture, byte *data, int width,
 		}
 	}
 
-	qglCompressedTextureImage2DEXT(texture, GL_TEXTURE_2D, mip, GL_COMPRESSED_RG_RGTC2, width, height, 0, size, compressedData);
+	// FIXME: Won't work for x/y that aren't multiples of 4.
+	qglCompressedTextureSubImage2DEXT(texture, GL_TEXTURE_2D, miplevel, x, y, width, height, GL_COMPRESSED_RG_RGTC2, size, compressedData);
 
 	ri.Hunk_FreeTempMemory(compressedData);
 }
@@ -1895,6 +1922,9 @@ static int CalculateMipSize(int width, int height, GLenum picFormat)
 		case GL_SRGB8_ALPHA8_EXT:
 			return numPixels * 4;
 
+		case GL_RGBA16:
+			return numPixels * 8;
+
 		default:
 			ri.Printf(PRINT_ALL, "Unsupported texture format %08x\n", picFormat);
 			return 0;
@@ -1904,64 +1934,33 @@ static int CalculateMipSize(int width, int height, GLenum picFormat)
 }
 
 
-static void RawImage_UploadTexture(GLuint texture, byte *data, int x, int y, int width, int height, GLenum target, GLenum picFormat, int numMips, GLenum internalFormat, imgType_t type, imgFlags_t flags, qboolean subtexture )
+static GLenum PixelDataFormatFromInternalFormat(GLenum internalFormat)
 {
-	int dataFormat, dataType;
-	qboolean rgtc = (internalFormat == GL_COMPRESSED_RG_RGTC2);
-	qboolean compressed = (!(picFormat == GL_RGBA8) || (picFormat == GL_SRGB8_ALPHA8_EXT));
-	qboolean mipmap = !!(flags & IMGFLAG_MIPMAP);
-	qboolean picmip = !!(flags & IMGFLAG_PICMIP);
-	int size, miplevel;
-	qboolean lastMip = qfalse;
-
 	switch (internalFormat)
 	{
 		case GL_DEPTH_COMPONENT:
 		case GL_DEPTH_COMPONENT16_ARB:
 		case GL_DEPTH_COMPONENT24_ARB:
 		case GL_DEPTH_COMPONENT32_ARB:
-			dataFormat = GL_DEPTH_COMPONENT;
-			dataType = GL_UNSIGNED_BYTE;
-			break;
-		case GL_RGBA16F_ARB:
-			dataFormat = GL_RGBA;
-			dataType = GL_HALF_FLOAT_ARB;
-			break;
+			return GL_DEPTH_COMPONENT;
 		default:
-			dataFormat = GL_RGBA;
-			dataType = GL_UNSIGNED_BYTE;
+			return GL_RGBA;
 			break;
 	}
+}
 
-	if (!data)
-	{
-		miplevel = 0;
-		do
-		{
-			lastMip = (width == 1 && height == 1) || !mipmap;
-			qglTextureImage2DEXT(texture, target, miplevel, internalFormat, width, height, 0, dataFormat, dataType, NULL);
-
-			width = MAX(1, width >> 1);
-			height = MAX(1, height >> 1);
-			miplevel++;
-		}
-		while (!lastMip);
-
-		return;
-	}
+static void RawImage_UploadTexture(GLuint texture, byte *data, int x, int y, int width, int height, GLenum target, GLenum picFormat, int numMips, GLenum internalFormat, imgType_t type, imgFlags_t flags, qboolean subtexture )
+{
+	GLenum dataFormat, dataType;
+	qboolean rgtc = internalFormat == GL_COMPRESSED_RG_RGTC2;
+	qboolean rgba8 = picFormat == GL_RGBA8 || picFormat == GL_SRGB8_ALPHA8_EXT;
+	qboolean rgba = rgba8 || picFormat == GL_RGBA16;
+	qboolean mipmap = !!(flags & IMGFLAG_MIPMAP);
+	int size, miplevel;
+	qboolean lastMip = qfalse;
 
-	if (compressed && picmip)
-	{
-		for (miplevel = r_picmip->integer; miplevel > 0 && numMips > 1; miplevel--, numMips--)
-		{
-			size = CalculateMipSize(width, height, picFormat);
-			x >>= 1;
-			y >>= 1;
-			width = MAX(1, width >> 1);
-			height = MAX(1, height >> 1);
-			data += size;
-		}
-	}
+	dataFormat = PixelDataFormatFromInternalFormat(internalFormat);
+	dataType = picFormat == GL_RGBA16 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_BYTE;
 
 	miplevel = 0;
 	do
@@ -1969,26 +1968,29 @@ static void RawImage_UploadTexture(GLuint texture, byte *data, int x, int y, int
 		lastMip = (width == 1 && height == 1) || !mipmap;
 		size = CalculateMipSize(width, height, picFormat);
 
-		if (compressed)
+		if (!rgba)
 		{
-			if (subtexture)
-				qglCompressedTextureSubImage2DEXT(texture, target, miplevel, x, y, width, height, picFormat, size, data);
-			else
-				qglCompressedTextureImage2DEXT(texture, target, miplevel, picFormat, width, height, 0, size, data);
+			qglCompressedTextureSubImage2DEXT(texture, target, miplevel, x, y, width, height, picFormat, size, data);
 		}
 		else
 		{
-			if (miplevel != 0 && r_colorMipLevels->integer)
+			if (rgba8 && miplevel != 0 && r_colorMipLevels->integer)
 				R_BlendOverTexture((byte *)data, width * height, mipBlendColors[miplevel]);
 
-			if (rgtc)
-				RawImage_UploadToRgtc2Texture(texture, data, width, height, miplevel);
-			else if (subtexture)
-				qglTextureSubImage2DEXT(texture, target, miplevel, x, y, width, height, dataFormat, dataType, data);
+			if (rgba8 && rgtc)
+				RawImage_UploadToRgtc2Texture(texture, miplevel, x, y, width, height, data);
 			else
-				qglTextureImage2DEXT(texture, target, miplevel, internalFormat, width, height, 0, dataFormat, dataType, data);
+				qglTextureSubImage2DEXT(texture, target, miplevel, x, y, width, height, dataFormat, dataType, data);
+		}
 
-			if (!lastMip && numMips < 2)
+		if (!lastMip && numMips < 2)
+		{
+			if (glRefConfig.framebufferObject)
+			{
+				qglGenerateTextureMipmapEXT(texture, target);
+				break;
+			}
+			else if (rgba8)
 			{
 				if (type == IMGTYPE_NORMAL || type == IMGTYPE_NORMALHEIGHT)
 					R_MipMapNormalHeight(data, data, width, height, glRefConfig.swizzleNormalmap);
@@ -2019,135 +2021,76 @@ Upload32
 
 ===============
 */
-static void Upload32(byte *data, int x, int y, int width, int height, GLenum picFormat, int numMips, image_t *image)
+static void Upload32(byte *data, int x, int y, int width, int height, GLenum picFormat, int numMips, image_t *image, qboolean scaled)
 {
-	byte		*resampledBuffer = NULL;
 	int			i, c;
 	byte		*scan;
 
 	imgType_t type = image->type;
 	imgFlags_t flags = image->flags;
 	GLenum internalFormat = image->internalFormat;
-	qboolean subtexture = (x != 0) || (y != 0) || (width != image->width) || (height != image->height);
-	qboolean notScaled = qtrue;
-	qboolean compressed = (picFormat != GL_RGBA8 && picFormat != GL_SRGB8_ALPHA8_EXT);
-	qboolean mipmap = !!(flags & IMGFLAG_MIPMAP) && (!compressed || numMips > 1);
+	qboolean rgba8 = picFormat == GL_RGBA8 || picFormat == GL_SRGB8_ALPHA8_EXT;
+	qboolean mipmap = !!(flags & IMGFLAG_MIPMAP) && (rgba8 || numMips > 1);
 	qboolean cubemap = !!(flags & IMGFLAG_CUBEMAP);
-	GLenum uploadTarget = cubemap ? GL_TEXTURE_CUBE_MAP_POSITIVE_X : GL_TEXTURE_2D;
-	GLenum textureTarget = cubemap ? GL_TEXTURE_CUBE_MAP : GL_TEXTURE_2D;
-	int depth = cubemap ? 6 : 1;
 
-	if (!data)
-	{
-		RawImage_ScaleToPower2(NULL, &width, &height, type, flags, NULL);
-		for (i = 0; i < depth; i++)
-			RawImage_UploadTexture(image->texnum, NULL, 0, 0, width, height, uploadTarget + i, GL_RGBA8, 0, internalFormat, type, flags, qfalse);
-		goto done;
-	}
-	else if (!subtexture)
+	// These operations cannot be performed on non-rgba8 images.
+	if (rgba8 && !cubemap)
 	{
-		if (compressed || cubemap)
+		c = width*height;
+		scan = data;
+
+		if (type == IMGTYPE_COLORALPHA)
 		{
-			for (i = 0; i < depth; i++)
+			if( r_greyscale->integer )
 			{
-				int w2 = width, h2 = height;
-				RawImage_UploadTexture(image->texnum, data, 0, 0, width, height, uploadTarget + i, picFormat, numMips, internalFormat, type, flags, qfalse);
-				for (c = numMips; c; c--)
+				for ( i = 0; i < c; i++ )
 				{
-					data += CalculateMipSize(w2, h2, picFormat);
-					w2 = MAX(1, w2 >> 1);
-					h2 = MAX(1, h2 >> 1);
+					byte luma = LUMA(scan[i*4], scan[i*4 + 1], scan[i*4 + 2]);
+					scan[i*4] = luma;
+					scan[i*4 + 1] = luma;
+					scan[i*4 + 2] = luma;
+				}
+			}
+			else if( r_greyscale->value )
+			{
+				for ( i = 0; i < c; i++ )
+				{
+					float luma = LUMA(scan[i*4], scan[i*4 + 1], scan[i*4 + 2]);
+					scan[i*4] = LERP(scan[i*4], luma, r_greyscale->value);
+					scan[i*4 + 1] = LERP(scan[i*4 + 1], luma, r_greyscale->value);
+					scan[i*4 + 2] = LERP(scan[i*4 + 2], luma, r_greyscale->value);
 				}
 			}
-			goto done;
-		}
-		notScaled = RawImage_ScaleToPower2(&data, &width, &height, type, flags, &resampledBuffer);
-	}
 
-	c = width*height;
-	scan = data;
-	
-	if( r_greyscale->integer )
-	{
-		for ( i = 0; i < c; i++ )
-		{
-			byte luma = LUMA(scan[i*4], scan[i*4 + 1], scan[i*4 + 2]);
-			scan[i*4] = luma;
-			scan[i*4 + 1] = luma;
-			scan[i*4 + 2] = luma;
+			// This corresponds to what the OpenGL1 renderer does.
+			if (!(flags & IMGFLAG_NOLIGHTSCALE) && (scaled || mipmap))
+				R_LightScaleTexture(data, width, height, !mipmap);
 		}
-	}
-	else if( r_greyscale->value )
-	{
-		for ( i = 0; i < c; i++ )
-		{
-			float luma = LUMA(scan[i*4], scan[i*4 + 1], scan[i*4 + 2]);
-			scan[i*4] = LERP(scan[i*4], luma, r_greyscale->value);
-			scan[i*4 + 1] = LERP(scan[i*4 + 1], luma, r_greyscale->value);
-			scan[i*4 + 2] = LERP(scan[i*4 + 2], luma, r_greyscale->value);
-		}
-	}
-
-	if (glRefConfig.swizzleNormalmap && (type == IMGTYPE_NORMAL || type == IMGTYPE_NORMALHEIGHT))
-		RawImage_SwizzleRA(data, width, height);
-
-	// This corresponds to what the OpenGL1 renderer does
-	if (!(flags & IMGFLAG_NOLIGHTSCALE) && (!notScaled || mipmap))
-		R_LightScaleTexture(data, width, height, !mipmap);
 
-	if (subtexture)
-	{
-		// FIXME: Incorrect if original texture was not a power of 2 texture or picmipped
-		RawImage_UploadTexture(image->texnum, data, x, y, width, height, uploadTarget, GL_RGBA8, 0, internalFormat, type, flags, qtrue);
-		GL_CheckErrors();
-		return;
+		if (glRefConfig.swizzleNormalmap && (type == IMGTYPE_NORMAL || type == IMGTYPE_NORMALHEIGHT))
+			RawImage_SwizzleRA(data, width, height);
 	}
 
-	RawImage_UploadTexture(image->texnum, data, 0, 0, width, height, uploadTarget, GL_RGBA8, 0, internalFormat, type, flags, qfalse);
-
-done:
-
-	image->uploadWidth  = width;
-	image->uploadHeight = height;
-
-	if (mipmap)
+	if (cubemap)
 	{
-		if (glConfig.textureFilterAnisotropic && !cubemap)
-			qglTextureParameteriEXT(image->texnum, textureTarget, GL_TEXTURE_MAX_ANISOTROPY_EXT,
-			(GLint)Com_Clamp(1, glConfig.maxAnisotropy, r_ext_max_anisotropy->integer));
-
-		qglTextureParameterfEXT(image->texnum, textureTarget, GL_TEXTURE_MIN_FILTER, gl_filter_min);
-		qglTextureParameterfEXT(image->texnum, textureTarget, GL_TEXTURE_MAG_FILTER, gl_filter_max);
+		for (i = 0; i < 6; i++)
+		{
+			int w2 = width, h2 = height;
+			RawImage_UploadTexture(image->texnum, data, x, y, width, height, GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, picFormat, numMips, internalFormat, type, flags, qfalse);
+			for (c = numMips; c; c--)
+			{
+				data += CalculateMipSize(w2, h2, picFormat);
+				w2 = MAX(1, w2 >> 1);
+				h2 = MAX(1, h2 >> 1);
+			}
+		}
 	}
 	else
 	{
-		if (glConfig.textureFilterAnisotropic && !cubemap)
-			qglTextureParameteriEXT(image->texnum, textureTarget, GL_TEXTURE_MAX_ANISOTROPY_EXT, 1);
-
-		qglTextureParameterfEXT(image->texnum, textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-		qglTextureParameterfEXT(image->texnum, textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-	}
-
-	// Fix for sampling depth buffer on old nVidia cards
-	// from http://www.idevgames.com/forums/thread-4141-post-34844.html#pid34844
-	switch(internalFormat)
-	{
-		case GL_DEPTH_COMPONENT:
-		case GL_DEPTH_COMPONENT16_ARB:
-		case GL_DEPTH_COMPONENT24_ARB:
-		case GL_DEPTH_COMPONENT32_ARB:
-			qglTextureParameterfEXT(image->texnum, textureTarget, GL_DEPTH_TEXTURE_MODE, GL_LUMINANCE);
-			qglTextureParameterfEXT(image->texnum, textureTarget, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-			qglTextureParameterfEXT(image->texnum, textureTarget, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-			break;
-		default:
-			break;
+		RawImage_UploadTexture(image->texnum, data, x, y, width, height, GL_TEXTURE_2D, picFormat, numMips, internalFormat, type, flags, qfalse);
 	}
 
 	GL_CheckErrors();
-
-	if ( resampledBuffer != NULL )
-		ri.Hunk_FreeTempMemory( resampledBuffer );
 }
 
 
@@ -2159,10 +2102,18 @@ This is the only way any image_t are created
 ================
 */
 image_t *R_CreateImage2( const char *name, byte *pic, int width, int height, GLenum picFormat, int numMips, imgType_t type, imgFlags_t flags, int internalFormat ) {
-	image_t		*image;
-	qboolean	isLightmap = qfalse;
-	long		hash;
-	int         glWrapClampMode;
+	byte       *resampledBuffer = NULL;
+	image_t    *image;
+	qboolean    isLightmap = qfalse, scaled = qfalse;
+	long        hash;
+	int         glWrapClampMode, mipWidth, mipHeight, miplevel;
+	qboolean    rgba8 = picFormat == GL_RGBA8 || picFormat == GL_SRGB8_ALPHA8_EXT;
+	qboolean    mipmap = !!(flags & IMGFLAG_MIPMAP);
+	qboolean    cubemap = !!(flags & IMGFLAG_CUBEMAP);
+	qboolean    picmip = !!(flags & IMGFLAG_PICMIP);
+	qboolean    lastMip;
+	GLenum textureTarget = cubemap ? GL_TEXTURE_CUBE_MAP : GL_TEXTURE_2D;
+	GLenum dataFormat;
 
 	if (strlen(name) >= MAX_QPATH ) {
 		ri.Error (ERR_DROP, "R_CreateImage: \"%s\" is too long", name);
@@ -2195,20 +2146,91 @@ image_t *R_CreateImage2( const char *name, byte *pic, int width, int height, GLe
 		internalFormat = RawImage_GetFormat(pic, width * height, picFormat, isLightmap, image->type, image->flags);
 
 	image->internalFormat = internalFormat;
-		
-	Upload32(pic, 0, 0, image->width, image->height, picFormat, numMips, image);
 
-	if (image->flags & IMGFLAG_CUBEMAP)
+	// Possibly scale image before uploading.
+	// if not rgba8 and uploading an image, skip picmips.
+	if (!cubemap)
 	{
-		qglTextureParameterfEXT(image->texnum, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, glWrapClampMode);
-		qglTextureParameterfEXT(image->texnum, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, glWrapClampMode);
-		qglTextureParameteriEXT(image->texnum, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, glWrapClampMode);
+		if (rgba8)
+			scaled = RawImage_ScaleToPower2(&pic, &width, &height, type, flags, &resampledBuffer);
+		else if (pic && picmip)
+		{
+			for (miplevel = r_picmip->integer; miplevel > 0 && numMips > 1; miplevel--, numMips--)
+			{
+				int size = CalculateMipSize(width, height, picFormat);
+				width = MAX(1, width >> 1);
+				height = MAX(1, height >> 1);
+				pic += size;
+			}
+		}
 	}
-	else
+
+	image->uploadWidth = width;
+	image->uploadHeight = height;
+
+	// Allocate texture storage so we don't have to worry about it later.
+	dataFormat = PixelDataFormatFromInternalFormat(internalFormat);
+	mipWidth = width;
+	mipHeight = height;
+	miplevel = 0;
+	do
 	{
-		qglTextureParameterfEXT(image->texnum, GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, glWrapClampMode);
-		qglTextureParameterfEXT(image->texnum, GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, glWrapClampMode);
+		lastMip = !mipmap || (mipWidth == 1 && mipHeight == 1);
+		if (cubemap)
+		{
+			int i;
+
+			for (i = 0; i < 6; i++)
+				qglTextureImage2DEXT(image->texnum, GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, miplevel, internalFormat, mipWidth, mipHeight, 0, dataFormat, GL_UNSIGNED_BYTE, NULL);
+		}
+		else
+		{
+			qglTextureImage2DEXT(image->texnum, GL_TEXTURE_2D, miplevel, internalFormat, mipWidth, mipHeight, 0, dataFormat, GL_UNSIGNED_BYTE, NULL);
+		}
+
+		mipWidth  = MAX(1, mipWidth >> 1);
+		mipHeight = MAX(1, mipHeight >> 1);
+		miplevel++;
 	}
+	while (!lastMip);
+
+	// Upload data.
+	if (pic)
+		Upload32(pic, 0, 0, width, height, picFormat, numMips, image, scaled);
+
+	if (resampledBuffer != NULL)
+		ri.Hunk_FreeTempMemory(resampledBuffer);
+
+	// Set all necessary texture parameters.
+	qglTextureParameterfEXT(image->texnum, textureTarget, GL_TEXTURE_WRAP_S, glWrapClampMode);
+	qglTextureParameterfEXT(image->texnum, textureTarget, GL_TEXTURE_WRAP_T, glWrapClampMode);
+
+	if (cubemap)
+		qglTextureParameteriEXT(image->texnum, textureTarget, GL_TEXTURE_WRAP_R, glWrapClampMode);
+
+	if (glConfig.textureFilterAnisotropic && !cubemap)
+		qglTextureParameteriEXT(image->texnum, textureTarget, GL_TEXTURE_MAX_ANISOTROPY_EXT,
+			mipmap ? (GLint)Com_Clamp(1, glConfig.maxAnisotropy, r_ext_max_anisotropy->integer) : 1);
+
+	switch(internalFormat)
+	{
+		case GL_DEPTH_COMPONENT:
+		case GL_DEPTH_COMPONENT16_ARB:
+		case GL_DEPTH_COMPONENT24_ARB:
+		case GL_DEPTH_COMPONENT32_ARB:
+			// Fix for sampling depth buffer on old nVidia cards.
+			// from http://www.idevgames.com/forums/thread-4141-post-34844.html#pid34844
+			qglTextureParameterfEXT(image->texnum, textureTarget, GL_DEPTH_TEXTURE_MODE, GL_LUMINANCE);
+			qglTextureParameterfEXT(image->texnum, textureTarget, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+			qglTextureParameterfEXT(image->texnum, textureTarget, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+			break;
+		default:
+			qglTextureParameterfEXT(image->texnum, textureTarget, GL_TEXTURE_MIN_FILTER, mipmap ? gl_filter_min : GL_LINEAR);
+			qglTextureParameterfEXT(image->texnum, textureTarget, GL_TEXTURE_MAG_FILTER, mipmap ? gl_filter_max : GL_LINEAR);
+			break;
+	}
+
+	GL_CheckErrors();
 
 	hash = generateHashValue(name);
 	image->next = hashTable[hash];
@@ -2231,9 +2253,9 @@ image_t *R_CreateImage(const char *name, byte *pic, int width, int height, imgTy
 }
 
 
-void R_UpdateSubImage( image_t *image, byte *pic, int x, int y, int width, int height )
+void R_UpdateSubImage( image_t *image, byte *pic, int x, int y, int width, int height, GLenum picFormat )
 {
-	Upload32(pic, x, y, width, height, GL_RGBA8, 0, image);
+	Upload32(pic, x, y, width, height, picFormat, 0, image, qfalse);
 }
 
 //===================================================================
@@ -2251,10 +2273,10 @@ typedef struct
 // when there are multiple images of different formats available
 static imageExtToLoaderMap_t imageLoaders[ ] =
 {
+	{ "png",  R_LoadPNG },
 	{ "tga",  R_LoadTGA },
 	{ "jpg",  R_LoadJPG },
 	{ "jpeg", R_LoadJPG },
-	{ "png",  R_LoadPNG },
 	{ "pcx",  R_LoadPCX },
 	{ "bmp",  R_LoadBMP }
 };
@@ -2736,19 +2758,11 @@ void R_CreateBuiltinImages( void ) {
 	{
 		int width, height, hdrFormat, rgbFormat;
 
-		if(glRefConfig.textureNonPowerOfTwo)
-		{
-			width = glConfig.vidWidth;
-			height = glConfig.vidHeight;
-		}
-		else
-		{
-			width = NextPowerOfTwo(glConfig.vidWidth);
-			height = NextPowerOfTwo(glConfig.vidHeight);
-		}
+		width = glConfig.vidWidth;
+		height = glConfig.vidHeight;
 
 		hdrFormat = GL_RGBA8;
-		if (r_hdr->integer && glRefConfig.framebufferObject && glRefConfig.textureFloat)
+		if (r_hdr->integer && glRefConfig.textureFloat)
 			hdrFormat = GL_RGBA16F_ARB;
 
 		rgbFormat = GL_RGBA8;
@@ -2768,25 +2782,13 @@ void R_CreateBuiltinImages( void ) {
 		tr.textureDepthImage = R_CreateImage("*texturedepth", NULL, PSHADOW_MAP_SIZE, PSHADOW_MAP_SIZE, IMGTYPE_COLORALPHA, IMGFLAG_NO_COMPRESSION | IMGFLAG_CLAMPTOEDGE, GL_DEPTH_COMPONENT24_ARB);
 
 		{
-			unsigned short sdata[4];
 			void *p;
 
-			if (hdrFormat == GL_RGBA16F_ARB)
-			{
-				sdata[0] = FloatToHalf(0.0f);
-				sdata[1] = FloatToHalf(0.45f);
-				sdata[2] = FloatToHalf(1.0f);
-				sdata[3] = FloatToHalf(1.0f);
-				p = &sdata[0];
-			}
-			else
-			{
-				data[0][0][0] = 0;
-				data[0][0][1] = 0.45f * 255;
-				data[0][0][2] = 255;
-				data[0][0][3] = 255;
-				p = data;
-			}
+			data[0][0][0] = 0;
+			data[0][0][1] = 0.45f * 255;
+			data[0][0][2] = 255;
+			data[0][0][3] = 255;
+			p = data;
 
 			tr.calcLevelsImage =   R_CreateImage("*calcLevels",    p, 1, 1, IMGTYPE_COLORALPHA, IMGFLAG_NO_COMPRESSION | IMGFLAG_CLAMPTOEDGE, hdrFormat);
 			tr.targetLevelsImage = R_CreateImage("*targetLevels",  p, 1, 1, IMGTYPE_COLORALPHA, IMGFLAG_NO_COMPRESSION | IMGFLAG_CLAMPTOEDGE, hdrFormat);
@@ -2846,11 +2848,7 @@ void R_SetColorMappings( void ) {
 	int		inf;
 
 	// setup the overbright lighting
-#if defined(USE_OVERBRIGHT)
 	tr.overbrightBits = r_overBrightBits->integer;
-#else
-	tr.overbrightBits = 0;
-#endif
 
 	// allow 2 overbright bits
 	if ( tr.overbrightBits > 2 ) {
diff --git a/src/renderergl2/tr_init.c b/src/renderergl2/tr_init.c
index 180c143..064df96 100644
--- a/src/renderergl2/tr_init.c
+++ b/src/renderergl2/tr_init.c
@@ -101,11 +101,8 @@ cvar_t  *r_ext_draw_range_elements;
 cvar_t  *r_ext_multi_draw_arrays;
 cvar_t  *r_ext_framebuffer_object;
 cvar_t  *r_ext_texture_float;
-cvar_t  *r_arb_half_float_pixel;
-cvar_t  *r_arb_half_float_vertex;
 cvar_t  *r_ext_framebuffer_multisample;
 cvar_t  *r_arb_seamless_cube_map;
-cvar_t  *r_arb_vertex_type_2_10_10_10_rev;
 cvar_t  *r_arb_vertex_array_object;
 cvar_t  *r_ext_direct_state_access;
 
@@ -155,7 +152,6 @@ cvar_t  *r_imageUpsampleMaxSize;
 cvar_t  *r_imageUpsampleType;
 cvar_t  *r_genNormalMaps;
 cvar_t  *r_forceSun;
-cvar_t  *r_forceSunMapLightScale;
 cvar_t  *r_forceSunLightScale;
 cvar_t  *r_forceSunAmbientScale;
 cvar_t  *r_sunlightMode;
@@ -884,7 +880,9 @@ void GL_SetDefaultState( void )
 	qglColor4f (1,1,1,1);
 
 	GL_BindNullTextures();
-	GL_BindNullFramebuffers();
+
+	if (glRefConfig.framebufferObject)
+		GL_BindNullFramebuffers();
 
 	qglEnable(GL_TEXTURE_2D);
 	GL_TextureMode( r_textureMode->string );
@@ -1093,11 +1091,8 @@ void R_Register( void )
 	r_ext_multi_draw_arrays = ri.Cvar_Get( "r_ext_multi_draw_arrays", "1", CVAR_ARCHIVE | CVAR_LATCH);
 	r_ext_framebuffer_object = ri.Cvar_Get( "r_ext_framebuffer_object", "1", CVAR_ARCHIVE | CVAR_LATCH);
 	r_ext_texture_float = ri.Cvar_Get( "r_ext_texture_float", "1", CVAR_ARCHIVE | CVAR_LATCH);
-	r_arb_half_float_pixel = ri.Cvar_Get( "r_arb_half_float_pixel", "1", CVAR_ARCHIVE | CVAR_LATCH);
-	r_arb_half_float_vertex = ri.Cvar_Get( "r_arb_half_float_vertex", "1", CVAR_ARCHIVE | CVAR_LATCH);
 	r_ext_framebuffer_multisample = ri.Cvar_Get( "r_ext_framebuffer_multisample", "0", CVAR_ARCHIVE | CVAR_LATCH);
 	r_arb_seamless_cube_map = ri.Cvar_Get( "r_arb_seamless_cube_map", "0", CVAR_ARCHIVE | CVAR_LATCH);
-	r_arb_vertex_type_2_10_10_10_rev = ri.Cvar_Get( "r_arb_vertex_type_2_10_10_10_rev", "1", CVAR_ARCHIVE | CVAR_LATCH);
 	r_arb_vertex_array_object = ri.Cvar_Get( "r_arb_vertex_array_object", "1", CVAR_ARCHIVE | CVAR_LATCH);
 	r_ext_direct_state_access = ri.Cvar_Get("r_ext_direct_state_access", "1", CVAR_ARCHIVE | CVAR_LATCH);
 
@@ -1177,7 +1172,6 @@ void R_Register( void )
 	r_genNormalMaps = ri.Cvar_Get( "r_genNormalMaps", "0", CVAR_ARCHIVE | CVAR_LATCH );
 
 	r_forceSun = ri.Cvar_Get( "r_forceSun", "0", CVAR_CHEAT );
-	r_forceSunMapLightScale = ri.Cvar_Get( "r_forceSunMapLightScale", "1.0", CVAR_CHEAT );
 	r_forceSunLightScale = ri.Cvar_Get( "r_forceSunLightScale", "1.0", CVAR_CHEAT );
 	r_forceSunAmbientScale = ri.Cvar_Get( "r_forceSunAmbientScale", "0.5", CVAR_CHEAT );
 	r_drawSunRays = ri.Cvar_Get( "r_drawSunRays", "0", CVAR_ARCHIVE | CVAR_LATCH );
diff --git a/src/renderergl2/tr_light.c b/src/renderergl2/tr_light.c
index 7c661dd..886d7fe 100644
--- a/src/renderergl2/tr_light.c
+++ b/src/renderergl2/tr_light.c
@@ -202,10 +202,10 @@ static void R_SetupEntityLightingGrid( trRefEntity_t *ent, world_t *world ) {
 			continue;
 		}
 
-		if (world->hdrLightGrid)
+		if (world->lightGrid16)
 		{
-			float *hdrData = world->hdrLightGrid + (int)(data - world->lightGridData) / 8 * 6;
-			if (!(hdrData[0]+hdrData[1]+hdrData[2]+hdrData[3]+hdrData[4]+hdrData[5]) ) {
+			uint16_t *data16 = world->lightGrid16 + (int)(data - world->lightGridData) / 8 * 6;
+			if (!(data16[0]+data16[1]+data16[2]+data16[3]+data16[4]+data16[5])) {
 				continue;	// ignore samples in walls
 			}
 		}
@@ -228,18 +228,18 @@ static void R_SetupEntityLightingGrid( trRefEntity_t *ent, world_t *world ) {
 		ent->directedLight[1] += factor * d4;
 		ent->directedLight[2] += factor * d5;
 		#else
-		if (world->hdrLightGrid)
+		if (world->lightGrid16)
 		{
 			// FIXME: this is hideous
-			float *hdrData = world->hdrLightGrid + (int)(data - world->lightGridData) / 8 * 6;
+			uint16_t *data16 = world->lightGrid16 + (int)(data - world->lightGridData) / 8 * 6;
 
-			ent->ambientLight[0] += factor * hdrData[0];
-			ent->ambientLight[1] += factor * hdrData[1];
-			ent->ambientLight[2] += factor * hdrData[2];
+			ent->ambientLight[0] += factor * data16[0] / 257.0f;
+			ent->ambientLight[1] += factor * data16[1] / 257.0f;
+			ent->ambientLight[2] += factor * data16[2] / 257.0f;
 
-			ent->directedLight[0] += factor * hdrData[3];
-			ent->directedLight[1] += factor * hdrData[4];
-			ent->directedLight[2] += factor * hdrData[5];
+			ent->directedLight[0] += factor * data16[3] / 257.0f;
+			ent->directedLight[1] += factor * data16[4] / 257.0f;
+			ent->directedLight[2] += factor * data16[5] / 257.0f;
 		}
 		else
 		{
@@ -386,16 +386,42 @@ void R_SetupEntityLighting( const trRefdef_t *refdef, trRefEntity_t *ent ) {
 		VectorMA( lightDir, d, dir, lightDir );
 	}
 
-	// clamp ambient
-	if ( !r_hdr->integer )
+	// clamp lights
+	// FIXME: old renderer clamps (ambient + NL * directed) per vertex
+	//        check if that's worth implementing
 	{
-		for ( i = 0 ; i < 3 ; i++ ) {
-			if ( ent->ambientLight[i] > tr.identityLightByte ) {
-				ent->ambientLight[i] = tr.identityLightByte;
-			}
+		float r, g, b, max;
+
+		r = ent->ambientLight[0];
+		g = ent->ambientLight[1];
+		b = ent->ambientLight[2];
+
+		max = MAX(MAX(r, g), b);
+
+		if (max > 255.0f)
+		{
+			max = 255.0f / max;
+			ent->ambientLight[0] *= max;
+			ent->ambientLight[1] *= max;
+			ent->ambientLight[2] *= max;
+		}
+
+		r = ent->directedLight[0];
+		g = ent->directedLight[1];
+		b = ent->directedLight[2];
+
+		max = MAX(MAX(r, g), b);
+
+		if (max > 255.0f)
+		{
+			max = 255.0f / max;
+			ent->directedLight[0] *= max;
+			ent->directedLight[1] *= max;
+			ent->directedLight[2] *= max;
 		}
 	}
 
+
 	if ( r_debugLight->integer ) {
 		LogLight( ent );
 	}
diff --git a/src/renderergl2/tr_local.h b/src/renderergl2/tr_local.h
index 3ebaa56..88e199c 100644
--- a/src/renderergl2/tr_local.h
+++ b/src/renderergl2/tr_local.h
@@ -56,9 +56,6 @@ typedef unsigned int glIndex_t;
 #define MAX_DRAWN_PSHADOWS    16 // do not increase past 32, because bit flags are used on surfaces
 #define PSHADOW_MAP_SIZE      512
 
-#define USE_VERT_TANGENT_SPACE
-#define USE_OVERBRIGHT
-
 typedef struct cubemap_s {
 	char name[MAX_QPATH];
 	vec3_t origin;
@@ -762,7 +759,6 @@ typedef struct {
 	float       sunDir[4];
 	float       sunCol[4];
 	float       sunAmbCol[4];
-	float       colorScale;
 
 	float       autoExposureMinMax[2];
 	float       toneMinAvgMaxLinear[3];
@@ -896,23 +892,17 @@ typedef struct
 	vec3_t          xyz;
 	vec2_t          st;
 	vec2_t          lightmap;
-	vec3_t          normal;
-#ifdef USE_VERT_TANGENT_SPACE
-	vec4_t          tangent;
-#endif
-	vec3_t          lightdir;
-	vec4_t			vertexColors;
+	int16_t         normal[4];
+	int16_t         tangent[4];
+	int16_t         lightdir[4];
+	uint16_t        color[4];
 
 #if DEBUG_OPTIMIZEVERTICES
 	unsigned int    id;
 #endif
 } srfVert_t;
 
-#ifdef USE_VERT_TANGENT_SPACE
-#define srfVert_t_cleared(x) srfVert_t (x) = {{0, 0, 0}, {0, 0}, {0, 0}, {0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0}, {0, 0, 0, 0}}
-#else
-#define srfVert_t_cleared(x) srfVert_t (x) = {{0, 0, 0}, {0, 0}, {0, 0}, {0, 0, 0}, {0, 0, 0},  {0, 0, 0, 0}}
-#endif
+#define srfVert_t_cleared(x) srfVert_t (x) = {{0, 0, 0}, {0, 0}, {0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}
 
 // srfBspSurface_t covers SF_GRID, SF_TRIANGLES, SF_POLY, and SF_VAO_MESH
 typedef struct srfBspSurface_s
@@ -1164,7 +1154,7 @@ typedef struct {
 	vec3_t		lightGridInverseSize;
 	int			lightGridBounds[3];
 	byte		*lightGridData;
-	float		*hdrLightGrid;
+	uint16_t	*lightGrid16;
 
 
 	int			numClusters;
@@ -1202,11 +1192,8 @@ typedef struct
 typedef struct
 {
 	vec3_t          xyz;
-	vec3_t          normal;
-#ifdef USE_VERT_TANGENT_SPACE
-	vec3_t          tangent;
-	vec3_t          bitangent;
-#endif
+	int16_t         normal[4];
+	int16_t         tangent[4];
 } mdvVertex_t;
 
 typedef struct
@@ -1387,6 +1374,8 @@ typedef struct {
 	int openglMajorVersion;
 	int openglMinorVersion;
 
+	qboolean    intelGraphics;
+
 	qboolean    drawRangeElements;
 	qboolean    multiDrawArrays;
 	qboolean	occlusionQuery;
@@ -1400,9 +1389,7 @@ typedef struct {
 	int maxRenderbufferSize;
 	int maxColorAttachments;
 
-	qboolean textureNonPowerOfTwo;
 	qboolean textureFloat;
-	qboolean halfFloatPixel;
 	textureCompressionRef_t textureCompression;
 	qboolean swizzleNormalmap;
 	
@@ -1412,13 +1399,6 @@ typedef struct {
 	qboolean depthClamp;
 	qboolean seamlessCubeMap;
 
-	GLenum packedNormalDataType;
-	GLenum packedTexcoordDataType;
-	GLenum packedColorDataType;
-	int packedTexcoordDataSize;
-	int packedColorDataSize;
-
-	qboolean floatLightmap;
 	qboolean vertexArrayObject;
 	qboolean directStateAccess;
 } glRefConfig_t;
@@ -1565,8 +1545,8 @@ typedef struct {
 	image_t					**lightmaps;
 	image_t					**deluxemaps;
 
-	int                     fatLightmapSize;
-	int		                fatLightmapStep;
+	int						fatLightmapCols;
+	int						fatLightmapRows;
 
 	int                     numCubemaps;
 	cubemap_t               *cubemaps;
@@ -1611,7 +1591,6 @@ typedef struct {
 
 	int						viewCluster;
 
-	float                   mapLightScale;
 	float                   sunShadowScale;
 
 	qboolean                sunShadows;
@@ -1716,11 +1695,8 @@ extern  cvar_t  *r_ext_draw_range_elements;
 extern  cvar_t  *r_ext_multi_draw_arrays;
 extern  cvar_t  *r_ext_framebuffer_object;
 extern  cvar_t  *r_ext_texture_float;
-extern  cvar_t  *r_arb_half_float_pixel;
-extern  cvar_t  *r_arb_half_float_vertex;
 extern  cvar_t  *r_ext_framebuffer_multisample;
 extern  cvar_t  *r_arb_seamless_cube_map;
-extern  cvar_t  *r_arb_vertex_type_2_10_10_10_rev;
 extern  cvar_t  *r_arb_vertex_array_object;
 extern  cvar_t  *r_ext_direct_state_access;
 
@@ -1806,7 +1782,6 @@ extern  cvar_t  *r_imageUpsampleMaxSize;
 extern  cvar_t  *r_imageUpsampleType;
 extern  cvar_t  *r_genNormalMaps;
 extern  cvar_t  *r_forceSun;
-extern  cvar_t  *r_forceSunMapLightScale;
 extern  cvar_t  *r_forceSunLightScale;
 extern  cvar_t  *r_forceSunAmbientScale;
 extern  cvar_t  *r_sunlightMode;
@@ -1863,7 +1838,7 @@ void R_AddDrawSurf( surfaceType_t *surface, shader_t *shader,
 
 void R_CalcTexDirs(vec3_t sdir, vec3_t tdir, const vec3_t v1, const vec3_t v2,
 				   const vec3_t v3, const vec2_t w1, const vec2_t w2, const vec2_t w3);
-void R_CalcTbnFromNormalAndTexDirs(vec3_t tangent, vec3_t bitangent, vec3_t normal, vec3_t sdir, vec3_t tdir);
+vec_t R_CalcTangentSpace(vec3_t tangent, vec3_t bitangent, const vec3_t normal, const vec3_t sdir, const vec3_t tdir);
 qboolean R_CalcTangentVectors(srfVert_t * dv[3]);
 
 #define	CULL_IN		0		// completely unclipped
@@ -1946,7 +1921,7 @@ qboolean	R_GetEntityToken( char *buffer, int size );
 model_t		*R_AllocModel( void );
 
 void    	R_Init( void );
-void		R_UpdateSubImage( image_t *image, byte *pic, int x, int y, int width, int height );
+void		R_UpdateSubImage( image_t *image, byte *pic, int x, int y, int width, int height, GLenum picFormat );
 
 void		R_SetColorMappings( void );
 void		R_GammaCorrect( byte *buffer, int bufSize );
@@ -2010,13 +1985,12 @@ typedef struct shaderCommands_s
 {
 	glIndex_t	indexes[SHADER_MAX_INDEXES] QALIGN(16);
 	vec4_t		xyz[SHADER_MAX_VERTEXES] QALIGN(16);
-	uint32_t	normal[SHADER_MAX_VERTEXES] QALIGN(16);
-#ifdef USE_VERT_TANGENT_SPACE
-	uint32_t	tangent[SHADER_MAX_VERTEXES] QALIGN(16);
-#endif
-	vec2_t		texCoords[SHADER_MAX_VERTEXES][2] QALIGN(16);
-	vec4_t		vertexColors[SHADER_MAX_VERTEXES] QALIGN(16);
-	uint32_t    lightdir[SHADER_MAX_VERTEXES] QALIGN(16);
+	int16_t		normal[SHADER_MAX_VERTEXES][4] QALIGN(16);
+	int16_t		tangent[SHADER_MAX_VERTEXES][4] QALIGN(16);
+	vec2_t		texCoords[SHADER_MAX_VERTEXES] QALIGN(16);
+	vec2_t		lightCoords[SHADER_MAX_VERTEXES] QALIGN(16);
+	uint16_t	color[SHADER_MAX_VERTEXES][4] QALIGN(16);
+	int16_t		lightdir[SHADER_MAX_VERTEXES][4] QALIGN(16);
 	//int			vertexDlightBits[SHADER_MAX_VERTEXES] QALIGN(16);
 
 	void *attribPointers[ATTR_INDEX_COUNT];
@@ -2158,7 +2132,6 @@ void R_SubdividePatchToGrid( srfBspSurface_t *grid, int width, int height,
 								srfVert_t points[MAX_PATCH_SIZE*MAX_PATCH_SIZE] );
 void R_GridInsertColumn( srfBspSurface_t *grid, int column, int row, vec3_t point, float loderror );
 void R_GridInsertRow( srfBspSurface_t *grid, int row, int column, vec3_t point, float loderror );
-void R_FreeSurfaceGridMesh( srfBspSurface_t *grid );
 
 /*
 ============================================================
@@ -2180,12 +2153,11 @@ VERTEX BUFFER OBJECTS
 ============================================================
 */
 
-int R_VaoPackTangent(byte *out, vec4_t v);
-int R_VaoPackNormal(byte *out, vec3_t v);
-int R_VaoPackTexCoord(byte *out, vec2_t st);
-int R_VaoPackColors(byte *out, vec4_t color);
-void R_VaoUnpackTangent(vec4_t v, uint32_t b);
-void R_VaoUnpackNormal(vec3_t v, uint32_t b);
+void R_VaoPackTangent(int16_t *out, vec4_t v);
+void R_VaoPackNormal(int16_t *out, vec3_t v);
+void R_VaoPackColor(uint16_t *out, vec4_t c);
+void R_VaoUnpackTangent(vec4_t v, int16_t *pack);
+void R_VaoUnpackNormal(vec3_t v, int16_t *pack);
 
 vao_t          *R_CreateVao(const char *name, byte *vertexes, int vertexesSize, byte *indexes, int indexesSize, vaoUsage_t usage);
 vao_t          *R_CreateVao2(const char *name, int numVertexes, srfVert_t *verts, int numIndexes, glIndex_t *inIndexes);
diff --git a/src/renderergl2/tr_main.c b/src/renderergl2/tr_main.c
index 9751ecb..0d86e4a 100644
--- a/src/renderergl2/tr_main.c
+++ b/src/renderergl2/tr_main.c
@@ -70,229 +70,6 @@ qboolean R_CompareVert(srfVert_t * v1, srfVert_t * v2, qboolean checkST)
 }
 
 /*
-=============
-R_CalcNormalForTriangle
-=============
-*/
-void R_CalcNormalForTriangle(vec3_t normal, const vec3_t v0, const vec3_t v1, const vec3_t v2)
-{
-	vec3_t          udir, vdir;
-
-	// compute the face normal based on vertex points
-	VectorSubtract(v2, v0, udir);
-	VectorSubtract(v1, v0, vdir);
-	CrossProduct(udir, vdir, normal);
-
-	VectorNormalize(normal);
-}
-
-/*
-=============
-R_CalcTangentsForTriangle
-http://members.rogers.com/deseric/tangentspace.htm
-=============
-*/
-void R_CalcTangentsForTriangle(vec3_t tangent, vec3_t bitangent,
-							   const vec3_t v0, const vec3_t v1, const vec3_t v2,
-							   const vec2_t t0, const vec2_t t1, const vec2_t t2)
-{
-	int             i;
-	vec3_t          planes[3];
-	vec3_t          u, v;
-
-	for(i = 0; i < 3; i++)
-	{
-		VectorSet(u, v1[i] - v0[i], t1[0] - t0[0], t1[1] - t0[1]);
-		VectorSet(v, v2[i] - v0[i], t2[0] - t0[0], t2[1] - t0[1]);
-
-		VectorNormalize(u);
-		VectorNormalize(v);
-
-		CrossProduct(u, v, planes[i]);
-	}
-
-	//So your tangent space will be defined by this :
-	//Normal = Normal of the triangle or Tangent X Bitangent (careful with the cross product,
-	// you have to make sure the normal points in the right direction)
-	//Tangent = ( dp(Fx(s,t)) / ds,  dp(Fy(s,t)) / ds, dp(Fz(s,t)) / ds )   or     ( -Bx/Ax, -By/Ay, - Bz/Az )
-	//Bitangent =  ( dp(Fx(s,t)) / dt,  dp(Fy(s,t)) / dt, dp(Fz(s,t)) / dt )  or     ( -Cx/Ax, -Cy/Ay, -Cz/Az )
-
-	// tangent...
-	tangent[0] = -planes[0][1] / planes[0][0];
-	tangent[1] = -planes[1][1] / planes[1][0];
-	tangent[2] = -planes[2][1] / planes[2][0];
-	VectorNormalize(tangent);
-
-	// bitangent...
-	bitangent[0] = -planes[0][2] / planes[0][0];
-	bitangent[1] = -planes[1][2] / planes[1][0];
-	bitangent[2] = -planes[2][2] / planes[2][0];
-	VectorNormalize(bitangent);
-}
-
-
-
-
-/*
-=============
-R_CalcTangentSpace
-=============
-*/
-void R_CalcTangentSpace(vec3_t tangent, vec3_t bitangent, vec3_t normal,
-						const vec3_t v0, const vec3_t v1, const vec3_t v2, const vec2_t t0, const vec2_t t1, const vec2_t t2)
-{
-	vec3_t          cp, u, v;
-	vec3_t          faceNormal;
-
-	VectorSet(u, v1[0] - v0[0], t1[0] - t0[0], t1[1] - t0[1]);
-	VectorSet(v, v2[0] - v0[0], t2[0] - t0[0], t2[1] - t0[1]);
-
-	CrossProduct(u, v, cp);
-	if(fabs(cp[0]) > 10e-6)
-	{
-		tangent[0] = -cp[1] / cp[0];
-		bitangent[0] = -cp[2] / cp[0];
-	}
-
-	u[0] = v1[1] - v0[1];
-	v[0] = v2[1] - v0[1];
-
-	CrossProduct(u, v, cp);
-	if(fabs(cp[0]) > 10e-6)
-	{
-		tangent[1] = -cp[1] / cp[0];
-		bitangent[1] = -cp[2] / cp[0];
-	}
-
-	u[0] = v1[2] - v0[2];
-	v[0] = v2[2] - v0[2];
-
-	CrossProduct(u, v, cp);
-	if(fabs(cp[0]) > 10e-6)
-	{
-		tangent[2] = -cp[1] / cp[0];
-		bitangent[2] = -cp[2] / cp[0];
-	}
-
-	VectorNormalize(tangent);
-	VectorNormalize(bitangent);
-
-	// compute the face normal based on vertex points
-	if ( normal[0] == 0.0f && normal[1] == 0.0f && normal[2] == 0.0f )
-	{
-		VectorSubtract(v2, v0, u);
-		VectorSubtract(v1, v0, v);
-		CrossProduct(u, v, faceNormal);
-	}
-	else
-	{
-		VectorCopy(normal, faceNormal);
-	}
-
-	VectorNormalize(faceNormal);
-
-#if 1
-	// Gram-Schmidt orthogonalize
-	//tangent[a] = (t - n * Dot(n, t)).Normalize();
-	VectorMA(tangent, -DotProduct(faceNormal, tangent), faceNormal, tangent);
-	VectorNormalize(tangent);
-
-	// compute the cross product B=NxT
-	//CrossProduct(normal, tangent, bitangent);
-#else
-	// normal, compute the cross product N=TxB
-	CrossProduct(tangent, bitangent, normal);
-	VectorNormalize(normal);
-
-	if(DotProduct(normal, faceNormal) < 0)
-	{
-		//VectorInverse(normal);
-		//VectorInverse(tangent);
-		//VectorInverse(bitangent);
-
-		// compute the cross product T=BxN
-		CrossProduct(bitangent, faceNormal, tangent);
-
-		// compute the cross product B=NxT
-		//CrossProduct(normal, tangent, bitangent);
-	}
-#endif
-
-	VectorCopy(faceNormal, normal);
-}
-
-void R_CalcTangentSpaceFast(vec3_t tangent, vec3_t bitangent, vec3_t normal,
-						const vec3_t v0, const vec3_t v1, const vec3_t v2, const vec2_t t0, const vec2_t t1, const vec2_t t2)
-{
-	vec3_t          cp, u, v;
-	vec3_t          faceNormal;
-
-	VectorSet(u, v1[0] - v0[0], t1[0] - t0[0], t1[1] - t0[1]);
-	VectorSet(v, v2[0] - v0[0], t2[0] - t0[0], t2[1] - t0[1]);
-
-	CrossProduct(u, v, cp);
-	if(fabs(cp[0]) > 10e-6)
-	{
-		tangent[0] = -cp[1] / cp[0];
-		bitangent[0] = -cp[2] / cp[0];
-	}
-
-	u[0] = v1[1] - v0[1];
-	v[0] = v2[1] - v0[1];
-
-	CrossProduct(u, v, cp);
-	if(fabs(cp[0]) > 10e-6)
-	{
-		tangent[1] = -cp[1] / cp[0];
-		bitangent[1] = -cp[2] / cp[0];
-	}
-
-	u[0] = v1[2] - v0[2];
-	v[0] = v2[2] - v0[2];
-
-	CrossProduct(u, v, cp);
-	if(fabs(cp[0]) > 10e-6)
-	{
-		tangent[2] = -cp[1] / cp[0];
-		bitangent[2] = -cp[2] / cp[0];
-	}
-
-	VectorNormalizeFast(tangent);
-	VectorNormalizeFast(bitangent);
-
-	// compute the face normal based on vertex points
-	VectorSubtract(v2, v0, u);
-	VectorSubtract(v1, v0, v);
-	CrossProduct(u, v, faceNormal);
-
-	VectorNormalizeFast(faceNormal);
-
-#if 0
-	// normal, compute the cross product N=TxB
-	CrossProduct(tangent, bitangent, normal);
-	VectorNormalizeFast(normal);
-
-	if(DotProduct(normal, faceNormal) < 0)
-	{
-		VectorInverse(normal);
-		//VectorInverse(tangent);
-		//VectorInverse(bitangent);
-
-		CrossProduct(normal, tangent, bitangent);
-	}
-
-	VectorCopy(faceNormal, normal);
-#else
-	// Gram-Schmidt orthogonalize
-		//tangent[a] = (t - n * Dot(n, t)).Normalize();
-	VectorMA(tangent, -DotProduct(faceNormal, tangent), faceNormal, tangent);
-	VectorNormalizeFast(tangent);
-#endif
-
-	VectorCopy(faceNormal, normal);
-}
-
-/*
 http://www.terathon.com/code/tangent.html
 */
 void R_CalcTexDirs(vec3_t sdir, vec3_t tdir, const vec3_t v1, const vec3_t v2,
@@ -313,13 +90,21 @@ void R_CalcTexDirs(vec3_t sdir, vec3_t tdir, const vec3_t v1, const vec3_t v2,
 	t1 = w2[1] - w1[1];
 	t2 = w3[1] - w1[1];
 
-	r = 1.0f / (s1 * t2 - s2 * t1);
+	r = s1 * t2 - s2 * t1;
+	if (r) r = 1.0f / r;
 
 	VectorSet(sdir, (t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
 	VectorSet(tdir, (s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
 }
 
-void R_CalcTbnFromNormalAndTexDirs(vec3_t tangent, vec3_t bitangent, vec3_t normal, vec3_t sdir, vec3_t tdir)
+/*
+=============
+R_CalcTangentSpace
+
+Lengyel, Eric. Computing Tangent Space Basis Vectors for an Arbitrary Mesh. Terathon Software 3D Graphics Library, 2001. http://www.terathon.com/src/tangent.html
+=============
+*/
+vec_t R_CalcTangentSpace(vec3_t tangent, vec3_t bitangent, const vec3_t normal, const vec3_t sdir, const vec3_t tdir)
 {
 	vec3_t n_cross_t;
 	vec_t n_dot_t, handedness;
@@ -333,114 +118,13 @@ void R_CalcTbnFromNormalAndTexDirs(vec3_t tangent, vec3_t bitangent, vec3_t norm
 	CrossProduct(normal, sdir, n_cross_t);
 	handedness = (DotProduct(n_cross_t, tdir) < 0.0f) ? -1.0f : 1.0f;
 
-	// Calculate bitangent
-	CrossProduct(normal, tangent, bitangent);
-	VectorScale(bitangent, handedness, bitangent);
-}
-
-void R_CalcTBN2(vec3_t tangent, vec3_t bitangent, vec3_t normal,
-						const vec3_t v1, const vec3_t v2, const vec3_t v3, const vec2_t t1, const vec2_t t2, const vec2_t t3)
-{
-	vec3_t			v2v1;
-	vec3_t			v3v1;
-
-	float			c2c1_T;
-	float			c2c1_B;
-
-	float			c3c1_T;
-	float			c3c1_B;
-
-	float			denominator;
-	float			scale1, scale2;
-
-	vec3_t			T, B, N, C;
-
-
-	// Calculate the tangent basis for each vertex of the triangle
-	// UPDATE: In the 3rd edition of the accompanying article, the for-loop located here has
-	// been removed as it was redundant (the entire TBN matrix was calculated three times
-	// instead of just one).
-	//
-	// Please note, that this function relies on the fact that the input geometry are triangles
-	// and the tangent basis for each vertex thus is identical!
-	//
-
-	// Calculate the vectors from the current vertex to the two other vertices in the triangle
-	VectorSubtract(v2, v1, v2v1);
-	VectorSubtract(v3, v1, v3v1);
-
-	// The equation presented in the article states that:
-	// c2c1_T = V2.texcoord.x - V1.texcoord.x
-	// c2c1_B = V2.texcoord.y - V1.texcoord.y
-	// c3c1_T = V3.texcoord.x - V1.texcoord.x
-	// c3c1_B = V3.texcoord.y - V1.texcoord.y
-
-	// Calculate c2c1_T and c2c1_B
-	c2c1_T = t2[0] - t1[0];
-	c2c1_B = t2[1] - t2[1];
-
-	// Calculate c3c1_T and c3c1_B
-	c3c1_T = t3[0] - t1[0];
-	c3c1_B = t3[1] - t1[1];
-
-	denominator = c2c1_T * c3c1_B - c3c1_T * c2c1_B;
-	//if(ROUNDOFF(fDenominator) == 0.0f)
-	if(denominator == 0.0f)
-	{
-		// We won't risk a divide by zero, so set the tangent matrix to the identity matrix
-		VectorSet(tangent, 1, 0, 0);
-		VectorSet(bitangent, 0, 1, 0);
-		VectorSet(normal, 0, 0, 1);
-	}
-	else
-	{
-		// Calculate the reciprocal value once and for all (to achieve speed)
-		scale1 = 1.0f / denominator;
-
-		// T and B are calculated just as the equation in the article states
-		VectorSet(T, (c3c1_B * v2v1[0] - c2c1_B * v3v1[0]) * scale1,
-					 (c3c1_B * v2v1[1] - c2c1_B * v3v1[1]) * scale1,
-					 (c3c1_B * v2v1[2] - c2c1_B * v3v1[2]) * scale1);
-
-		VectorSet(B, (-c3c1_T * v2v1[0] + c2c1_T * v3v1[0]) * scale1,
-					 (-c3c1_T * v2v1[1] + c2c1_T * v3v1[1]) * scale1,
-					 (-c3c1_T * v2v1[2] + c2c1_T * v3v1[2]) * scale1);
-
-		// The normal N is calculated as the cross product between T and B
-		CrossProduct(T, B, N);
-
-#if 0
-		VectorCopy(T, tangent);
-		VectorCopy(B, bitangent);
-		VectorCopy(N, normal);
-#else
-		// Calculate the reciprocal value once and for all (to achieve speed)
-		scale2 = 1.0f / ((T[0] * B[1] * N[2] - T[2] * B[1] * N[0]) +
-					(B[0] * N[1] * T[2] - B[2] * N[1] * T[0]) +
-					(N[0] * T[1] * B[2] - N[2] * T[1] * B[0]));
-
-		// Calculate the inverse if the TBN matrix using the formula described in the article.
-		// We store the basis vectors directly in the provided TBN matrix: pvTBNMatrix
-		CrossProduct(B, N, C); tangent[0] = C[0] * scale2;
-		CrossProduct(N, T, C); tangent[1] = -C[0] * scale2;
-		CrossProduct(T, B, C); tangent[2] = C[0] * scale2;
-		VectorNormalize(tangent);
-
-		CrossProduct(B, N, C); bitangent[0] = -C[1] * scale2;
-		CrossProduct(N, T, C); bitangent[1] = C[1] * scale2;
-		CrossProduct(T, B, C); bitangent[2] = -C[1] * scale2;
-		VectorNormalize(bitangent);
+	// Calculate orthogonal bitangent, if necessary
+	if (bitangent)
+		CrossProduct(normal, tangent, bitangent);
 
-		CrossProduct(B, N, C); normal[0] = C[2] * scale2;
-		CrossProduct(N, T, C); normal[1] = -C[2] * scale2;
-		CrossProduct(T, B, C); normal[2] = C[2] * scale2;
-		VectorNormalize(normal);
-#endif
-	}
+	return handedness;
 }
 
-
-#ifdef USE_VERT_TANGENT_SPACE
 qboolean R_CalcTangentVectors(srfVert_t * dv[3])
 {
 	int             i;
@@ -456,7 +140,8 @@ qboolean R_CalcTangentVectors(srfVert_t * dv[3])
 	/* do each vertex */
 	for(i = 0; i < 3; i++)
 	{
-		vec3_t bitangent, nxt;
+		vec4_t tangent;
+		vec3_t normal, bitangent, nxt;
 
 		// calculate s tangent vector
 		s = dv[i]->st[0] + 10.0f;
@@ -465,12 +150,12 @@ qboolean R_CalcTangentVectors(srfVert_t * dv[3])
 		bary[1] = ((dv[2]->st[0] - s) * (dv[0]->st[1] - t) - (dv[0]->st[0] - s) * (dv[2]->st[1] - t)) / bb;
 		bary[2] = ((dv[0]->st[0] - s) * (dv[1]->st[1] - t) - (dv[1]->st[0] - s) * (dv[0]->st[1] - t)) / bb;
 
-		dv[i]->tangent[0] = bary[0] * dv[0]->xyz[0] + bary[1] * dv[1]->xyz[0] + bary[2] * dv[2]->xyz[0];
-		dv[i]->tangent[1] = bary[0] * dv[0]->xyz[1] + bary[1] * dv[1]->xyz[1] + bary[2] * dv[2]->xyz[1];
-		dv[i]->tangent[2] = bary[0] * dv[0]->xyz[2] + bary[1] * dv[1]->xyz[2] + bary[2] * dv[2]->xyz[2];
+		tangent[0] = bary[0] * dv[0]->xyz[0] + bary[1] * dv[1]->xyz[0] + bary[2] * dv[2]->xyz[0];
+		tangent[1] = bary[0] * dv[0]->xyz[1] + bary[1] * dv[1]->xyz[1] + bary[2] * dv[2]->xyz[1];
+		tangent[2] = bary[0] * dv[0]->xyz[2] + bary[1] * dv[1]->xyz[2] + bary[2] * dv[2]->xyz[2];
 
-		VectorSubtract(dv[i]->tangent, dv[i]->xyz, dv[i]->tangent);
-		VectorNormalize(dv[i]->tangent);
+		VectorSubtract(tangent, dv[i]->xyz, tangent);
+		VectorNormalize(tangent);
 
 		// calculate t tangent vector
 		s = dv[i]->st[0];
@@ -487,8 +172,11 @@ qboolean R_CalcTangentVectors(srfVert_t * dv[3])
 		VectorNormalize(bitangent);
 
 		// store bitangent handedness
-		CrossProduct(dv[i]->normal, dv[i]->tangent, nxt);
-		dv[i]->tangent[3] = (DotProduct(nxt, bitangent) < 0.0f) ? -1.0f : 1.0f;
+		R_VaoUnpackNormal(normal, dv[i]->normal);
+		CrossProduct(normal, tangent, nxt);
+		tangent[3] = (DotProduct(nxt, bitangent) < 0.0f) ? -1.0f : 1.0f;
+
+		R_VaoPackTangent(dv[i]->tangent, tangent);
 
 		// debug code
 		//% Sys_FPrintf( SYS_VRB, "%d S: (%f %f %f) T: (%f %f %f)\n", i,
@@ -497,7 +185,6 @@ qboolean R_CalcTangentVectors(srfVert_t * dv[3])
 
 	return qtrue;
 }
-#endif
 
 
 /*
@@ -1643,8 +1330,8 @@ qboolean R_MirrorViewBySurface (drawSurf_t *drawSurf, int entityNum) {
 		return qfalse;		// bad portal, no portalentity
 	}
 
-	if (newParms.isMirror)
-		newParms.flags |= VPF_NOVIEWMODEL;
+	// Never draw viewmodels in portal or mirror views.
+	newParms.flags |= VPF_NOVIEWMODEL;
 
 	R_MirrorPoint (oldParms.or.origin, &surface, &camera, newParms.or.origin );
 
@@ -2363,7 +2050,7 @@ void R_RenderPshadowMaps(const refdef_t *fd)
 		VectorScale(lightDir, -1.0f, shadow->lightViewAxis[0]);
 		VectorSet(up, 0, 0, -1);
 
-		if ( abs(DotProduct(up, shadow->lightViewAxis[0])) > 0.9f )
+		if ( fabsf(DotProduct(up, shadow->lightViewAxis[0])) > 0.9f )
 		{
 			VectorSet(up, -1, 0, 0);
 		}
@@ -2606,7 +2293,7 @@ void R_RenderSunShadowMaps(const refdef_t *fd, int level)
 	}
 
 	// Check if too close to parallel to light direction
-	if (abs(DotProduct(lightViewAxis[2], lightViewAxis[0])) > 0.9f)
+	if (fabsf(DotProduct(lightViewAxis[2], lightViewAxis[0])) > 0.9f)
 	{
 		if (level == 3 || lightViewIndependentOfCameraView)
 		{
@@ -2859,7 +2546,6 @@ void R_RenderCubemapSide( int cubemapIndex, int cubemapSide, qboolean subscene )
 {
 	refdef_t refdef;
 	viewParms_t	parms;
-	float oldColorScale = tr.refdef.colorScale;
 
 	memset( &refdef, 0, sizeof( refdef ) );
 	refdef.rdflags = 0;
@@ -2937,7 +2623,6 @@ void R_RenderCubemapSide( int cubemapIndex, int cubemapSide, qboolean subscene )
 		R_LightForPoint(tr.refdef.vieworg, ambient, directed, lightDir);
 		scale = directed[0] + directed[1] + directed[2] + ambient[0] + ambient[1] + ambient[2] + 1.0f;
 
-		tr.refdef.colorScale = 1.0f; //766.0f / scale;
 		// only print message for first side
 		if (scale < 1.0001f && cubemapSide == 0)
 		{
@@ -2978,12 +2663,6 @@ void R_RenderCubemapSide( int cubemapIndex, int cubemapSide, qboolean subscene )
 
 	R_RenderView(&parms);
 
-	if (subscene)
-	{
-		tr.refdef.colorScale = oldColorScale;
-	}
-	else
-	{
+	if (!subscene)
 		RE_EndScene();
-	}
 }
diff --git a/src/renderergl2/tr_marks.c b/src/renderergl2/tr_marks.c
index f698262..6fc468e 100644
--- a/src/renderergl2/tr_marks.c
+++ b/src/renderergl2/tr_marks.c
@@ -351,17 +351,21 @@ int R_MarkFragments( int numPoints, const vec3_t *points, const vec3_t projectio
 					// The offset is added in the vertex normal vector direction
 					// so all triangles will still fit together.
 					// The 2 unit offset should avoid pretty much all LOD problems.
+					vec3_t fNormal;
 
 					numClipPoints = 3;
 
 					dv = cv->verts + m * cv->width + n;
 
 					VectorCopy(dv[0].xyz, clipPoints[0][0]);
-					VectorMA(clipPoints[0][0], MARKER_OFFSET, dv[0].normal, clipPoints[0][0]);
+					R_VaoUnpackNormal(fNormal, dv[0].normal);
+					VectorMA(clipPoints[0][0], MARKER_OFFSET, fNormal, clipPoints[0][0]);
 					VectorCopy(dv[cv->width].xyz, clipPoints[0][1]);
-					VectorMA(clipPoints[0][1], MARKER_OFFSET, dv[cv->width].normal, clipPoints[0][1]);
+					R_VaoUnpackNormal(fNormal, dv[cv->width].normal);
+					VectorMA(clipPoints[0][1], MARKER_OFFSET, fNormal, clipPoints[0][1]);
 					VectorCopy(dv[1].xyz, clipPoints[0][2]);
-					VectorMA(clipPoints[0][2], MARKER_OFFSET, dv[1].normal, clipPoints[0][2]);
+					R_VaoUnpackNormal(fNormal, dv[1].normal);
+					VectorMA(clipPoints[0][2], MARKER_OFFSET, fNormal, clipPoints[0][2]);
 					// check the normal of this triangle
 					VectorSubtract(clipPoints[0][0], clipPoints[0][1], v1);
 					VectorSubtract(clipPoints[0][2], clipPoints[0][1], v2);
@@ -381,11 +385,14 @@ int R_MarkFragments( int numPoints, const vec3_t *points, const vec3_t projectio
 					}
 
 					VectorCopy(dv[1].xyz, clipPoints[0][0]);
-					VectorMA(clipPoints[0][0], MARKER_OFFSET, dv[1].normal, clipPoints[0][0]);
+					R_VaoUnpackNormal(fNormal, dv[1].normal);
+					VectorMA(clipPoints[0][0], MARKER_OFFSET, fNormal, clipPoints[0][0]);
 					VectorCopy(dv[cv->width].xyz, clipPoints[0][1]);
-					VectorMA(clipPoints[0][1], MARKER_OFFSET, dv[cv->width].normal, clipPoints[0][1]);
+					R_VaoUnpackNormal(fNormal, dv[cv->width].normal);
+					VectorMA(clipPoints[0][1], MARKER_OFFSET, fNormal, clipPoints[0][1]);
 					VectorCopy(dv[cv->width+1].xyz, clipPoints[0][2]);
-					VectorMA(clipPoints[0][2], MARKER_OFFSET, dv[cv->width+1].normal, clipPoints[0][2]);
+					R_VaoUnpackNormal(fNormal, dv[cv->width + 1].normal);
+					VectorMA(clipPoints[0][2], MARKER_OFFSET, fNormal, clipPoints[0][2]);
 					// check the normal of this triangle
 					VectorSubtract(clipPoints[0][0], clipPoints[0][1], v1);
 					VectorSubtract(clipPoints[0][2], clipPoints[0][1], v2);
@@ -442,8 +449,10 @@ int R_MarkFragments( int numPoints, const vec3_t *points, const vec3_t projectio
 			{
 				for(j = 0; j < 3; j++)
 				{
+					vec3_t fNormal;
 					v = surf->verts[tri[j]].xyz;
-					VectorMA(v, MARKER_OFFSET, surf->verts[tri[j]].normal, clipPoints[0][j]);
+					R_VaoUnpackNormal(fNormal, surf->verts[tri[j]].normal);
+					VectorMA(v, MARKER_OFFSET, fNormal, clipPoints[0][j]);
 				}
 
 				// add the fragments of this face
diff --git a/src/renderergl2/tr_model.c b/src/renderergl2/tr_model.c
index 544917b..1877daa 100644
--- a/src/renderergl2/tr_model.c
+++ b/src/renderergl2/tr_model.c
@@ -563,6 +563,7 @@ static qboolean R_LoadMD3(model_t * mod, int lod, void *buffer, int bufferSize,
 		{
 			unsigned lat, lng;
 			unsigned short normal;
+			vec3_t fNormal;
 
 			v->xyz[0] = LittleShort(md3xyz->xyz[0]) * MD3_XYZ_SCALE;
 			v->xyz[1] = LittleShort(md3xyz->xyz[1]) * MD3_XYZ_SCALE;
@@ -579,9 +580,11 @@ static qboolean R_LoadMD3(model_t * mod, int lod, void *buffer, int bufferSize,
 			// decode Y as sin( lat ) * sin( long )
 			// decode Z as cos( long )
 
-			v->normal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
-			v->normal[1] = tr.sinTable[lat] * tr.sinTable[lng];
-			v->normal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
+			fNormal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
+			fNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
+			fNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
+
+			R_VaoPackNormal(v->normal, fNormal);
 		}
 
 		// swap all the ST
@@ -594,13 +597,15 @@ static qboolean R_LoadMD3(model_t * mod, int lod, void *buffer, int bufferSize,
 			st->st[1] = LittleFloat(md3st->st[1]);
 		}
 
-#ifdef USE_VERT_TANGENT_SPACE
 		// calc tangent spaces
 		{
+			vec3_t *sdirs = ri.Malloc(sizeof(*sdirs) * surf->numVerts * mdvModel->numFrames);
+			vec3_t *tdirs = ri.Malloc(sizeof(*tdirs) * surf->numVerts * mdvModel->numFrames);
+
 			for(j = 0, v = surf->verts; j < (surf->numVerts * mdvModel->numFrames); j++, v++)
 			{
-				VectorClear(v->tangent);
-				VectorClear(v->bitangent);
+				VectorClear(sdirs[j]);
+				VectorClear(tdirs[j]);
 			}
 
 			for(f = 0; f < mdvModel->numFrames; f++)
@@ -625,29 +630,33 @@ static qboolean R_LoadMD3(model_t * mod, int lod, void *buffer, int bufferSize,
 
 					R_CalcTexDirs(sdir, tdir, v0, v1, v2, t0, t1, t2);
 
-					VectorAdd(sdir, surf->verts[index0].tangent,   surf->verts[index0].tangent);
-					VectorAdd(sdir, surf->verts[index1].tangent,   surf->verts[index1].tangent);
-					VectorAdd(sdir, surf->verts[index2].tangent,   surf->verts[index2].tangent);
-					VectorAdd(tdir, surf->verts[index0].bitangent, surf->verts[index0].bitangent);
-					VectorAdd(tdir, surf->verts[index1].bitangent, surf->verts[index1].bitangent);
-					VectorAdd(tdir, surf->verts[index2].bitangent, surf->verts[index2].bitangent);
+					VectorAdd(sdir, sdirs[index0], sdirs[index0]);
+					VectorAdd(sdir, sdirs[index1], sdirs[index1]);
+					VectorAdd(sdir, sdirs[index2], sdirs[index2]);
+					VectorAdd(tdir, tdirs[index0], tdirs[index0]);
+					VectorAdd(tdir, tdirs[index1], tdirs[index1]);
+					VectorAdd(tdir, tdirs[index2], tdirs[index2]);
 				}
 			}
 
 			for(j = 0, v = surf->verts; j < (surf->numVerts * mdvModel->numFrames); j++, v++)
 			{
-				vec3_t sdir, tdir;
+				vec3_t normal;
+				vec4_t tangent;
 
-				VectorCopy(v->tangent,   sdir);
-				VectorCopy(v->bitangent, tdir);
+				VectorNormalize(sdirs[j]);
+				VectorNormalize(tdirs[j]);
 
-				VectorNormalize(sdir);
-				VectorNormalize(tdir);
+				R_VaoUnpackNormal(normal, v->normal);
 
-				R_CalcTbnFromNormalAndTexDirs(v->tangent, v->bitangent, v->normal, sdir, tdir);
+				tangent[3] = R_CalcTangentSpace(tangent, NULL, normal, sdirs[j], tdirs[j]);
+
+				R_VaoPackTangent(v->tangent, tangent);
 			}
+
+			ri.Free(sdirs);
+			ri.Free(tdirs);
 		}
-#endif
 
 		// find the next surface
 		md3Surf = (md3Surface_t *) ((byte *) md3Surf + md3Surf->ofsEnd);
@@ -673,14 +682,12 @@ static qboolean R_LoadMD3(model_t * mod, int lod, void *buffer, int bufferSize,
 			{
 				// vertex animation, store texcoords first, then position/normal/tangents
 				offset_st      = 0;
-				offset_xyz     = surf->numVerts * glRefConfig.packedTexcoordDataSize;
+				offset_xyz     = surf->numVerts * sizeof(vec2_t);
 				offset_normal  = offset_xyz + sizeof(vec3_t);
-				offset_tangent = offset_normal + sizeof(uint32_t);
-				stride_st  = glRefConfig.packedTexcoordDataSize;
-				stride_xyz = sizeof(vec3_t) + sizeof(uint32_t);
-#ifdef USE_VERT_TANGENT_SPACE
-				stride_xyz += sizeof(uint32_t);
-#endif
+				offset_tangent = offset_normal + sizeof(int16_t) * 4;
+				stride_st  = sizeof(vec2_t);
+				stride_xyz = sizeof(vec3_t) + sizeof(int16_t) * 4;
+				stride_xyz += sizeof(int16_t) * 4;
 				stride_normal = stride_tangent = stride_xyz;
 
 				dataSize = offset_xyz + surf->numVerts * mdvModel->numFrames * stride_xyz;
@@ -690,13 +697,9 @@ static qboolean R_LoadMD3(model_t * mod, int lod, void *buffer, int bufferSize,
 				// no animation, interleave everything
 				offset_xyz     = 0;
 				offset_st      = offset_xyz + sizeof(vec3_t);
-				offset_normal  = offset_st + glRefConfig.packedTexcoordDataSize;
-				offset_tangent = offset_normal + sizeof(uint32_t);
-#ifdef USE_VERT_TANGENT_SPACE
-				stride_xyz = offset_tangent + sizeof(uint32_t);
-#else
-				stride_xyz = offset_normal + sizeof(uint32_t);
-#endif
+				offset_normal  = offset_st + sizeof(vec2_t);
+				offset_tangent = offset_normal + sizeof(int16_t) * 4;
+				stride_xyz = offset_tangent + sizeof(int16_t) * 4;
 				stride_st = stride_normal = stride_tangent = stride_xyz;
 
 				dataSize = surf->numVerts * stride_xyz;
@@ -710,31 +713,24 @@ static qboolean R_LoadMD3(model_t * mod, int lod, void *buffer, int bufferSize,
 			{
 				st = surf->st;
 				for ( j = 0 ; j < surf->numVerts ; j++, st++ ) {
-					dataOfs += R_VaoPackTexCoord(data + dataOfs, st->st);
+					memcpy(data + dataOfs, &st->st, sizeof(vec2_t));
+					dataOfs += sizeof(st->st);
 				}
 
 				v = surf->verts;
 				for ( j = 0; j < surf->numVerts * mdvModel->numFrames ; j++, v++ )
 				{
-#ifdef USE_VERT_TANGENT_SPACE
-					vec3_t nxt;
-					vec4_t tangent;
-#endif
 					// xyz
 					memcpy(data + dataOfs, &v->xyz, sizeof(vec3_t));
 					dataOfs += sizeof(vec3_t);
 
 					// normal
-					dataOfs += R_VaoPackNormal(data + dataOfs, v->normal);
-
-#ifdef USE_VERT_TANGENT_SPACE
-					CrossProduct(v->normal, v->tangent, nxt);
-					VectorCopy(v->tangent, tangent);
-					tangent[3] = (DotProduct(nxt, v->bitangent) < 0.0f) ? -1.0f : 1.0f;
+					memcpy(data + dataOfs, &v->normal, sizeof(int16_t) * 4);
+					dataOfs += sizeof(int16_t) * 4;
 
 					// tangent
-					dataOfs += R_VaoPackTangent(data + dataOfs, tangent);
-#endif
+					memcpy(data + dataOfs, &v->tangent, sizeof(int16_t) * 4);
+					dataOfs += sizeof(int16_t) * 4;
 				}
 			}
 			else
@@ -743,28 +739,21 @@ static qboolean R_LoadMD3(model_t * mod, int lod, void *buffer, int bufferSize,
 				st = surf->st;
 				for ( j = 0; j < surf->numVerts; j++, v++, st++ )
 				{
-#ifdef USE_VERT_TANGENT_SPACE
-					vec3_t nxt;
-					vec4_t tangent;
-#endif
 					// xyz
 					memcpy(data + dataOfs, &v->xyz, sizeof(vec3_t));
 					dataOfs += sizeof(v->xyz);
 
 					// st
-					dataOfs += R_VaoPackTexCoord(data + dataOfs, st->st);
+					memcpy(data + dataOfs, &st->st, sizeof(vec2_t));
+					dataOfs += sizeof(st->st);
 
 					// normal
-					dataOfs += R_VaoPackNormal(data + dataOfs, v->normal);
-
-#ifdef USE_VERT_TANGENT_SPACE
-					CrossProduct(v->normal, v->tangent, nxt);
-					VectorCopy(v->tangent, tangent);
-					tangent[3] = (DotProduct(nxt, v->bitangent) < 0.0f) ? -1.0f : 1.0f;
+					memcpy(data + dataOfs, &v->normal, sizeof(int16_t) * 4);
+					dataOfs += sizeof(int16_t) * 4;
 
 					// tangent
-					dataOfs += R_VaoPackTangent(data + dataOfs, tangent);
-#endif
+					memcpy(data + dataOfs, &v->tangent, sizeof(int16_t) * 4);
+					dataOfs += sizeof(int16_t) * 4;
 				}
 			}
 
@@ -782,9 +771,7 @@ static qboolean R_LoadMD3(model_t * mod, int lod, void *buffer, int bufferSize,
 			vaoSurf->vao->attribs[ATTR_INDEX_POSITION].enabled = 1;
 			vaoSurf->vao->attribs[ATTR_INDEX_TEXCOORD].enabled = 1;
 			vaoSurf->vao->attribs[ATTR_INDEX_NORMAL  ].enabled = 1;
-#ifdef USE_VERT_TANGENT_SPACE
 			vaoSurf->vao->attribs[ATTR_INDEX_TANGENT ].enabled = 1;
-#endif
 
 			vaoSurf->vao->attribs[ATTR_INDEX_POSITION].count = 3;
 			vaoSurf->vao->attribs[ATTR_INDEX_TEXCOORD].count = 2;
@@ -792,9 +779,9 @@ static qboolean R_LoadMD3(model_t * mod, int lod, void *buffer, int bufferSize,
 			vaoSurf->vao->attribs[ATTR_INDEX_TANGENT ].count = 4;
 
 			vaoSurf->vao->attribs[ATTR_INDEX_POSITION].type = GL_FLOAT;
-			vaoSurf->vao->attribs[ATTR_INDEX_TEXCOORD].type = glRefConfig.packedTexcoordDataType;
-			vaoSurf->vao->attribs[ATTR_INDEX_NORMAL  ].type = glRefConfig.packedNormalDataType;
-			vaoSurf->vao->attribs[ATTR_INDEX_TANGENT ].type = glRefConfig.packedNormalDataType;
+			vaoSurf->vao->attribs[ATTR_INDEX_TEXCOORD].type = GL_FLOAT;
+			vaoSurf->vao->attribs[ATTR_INDEX_NORMAL  ].type = GL_SHORT;
+			vaoSurf->vao->attribs[ATTR_INDEX_TANGENT ].type = GL_SHORT;
 
 			vaoSurf->vao->attribs[ATTR_INDEX_POSITION].normalized = GL_FALSE;
 			vaoSurf->vao->attribs[ATTR_INDEX_TEXCOORD].normalized = GL_FALSE;
diff --git a/src/renderergl2/tr_model_iqm.c b/src/renderergl2/tr_model_iqm.c
index 809d120..19f0d5c 100644
--- a/src/renderergl2/tr_model_iqm.c
+++ b/src/renderergl2/tr_model_iqm.c
@@ -1024,12 +1024,10 @@ void RB_IQMSurfaceAnim( surfaceType_t *surface ) {
 	int		i;
 
 	vec4_t		*outXYZ;
-	uint32_t	*outNormal;
-#ifdef USE_VERT_TANGENT_SPACE
-	uint32_t	*outTangent;
-#endif
-	vec2_t		(*outTexCoord)[2];
-	vec4_t	*outColor;
+	int16_t	*outNormal;
+	int16_t	*outTangent;
+	vec2_t		*outTexCoord;
+	uint16_t *outColor;
 
 	int	frame = data->num_frames ? backEnd.currentEntity->e.frame % data->num_frames : 0;
 	int	oldframe = data->num_frames ? backEnd.currentEntity->e.oldframe % data->num_frames : 0;
@@ -1042,12 +1040,10 @@ void RB_IQMSurfaceAnim( surfaceType_t *surface ) {
 	RB_CHECKOVERFLOW( surf->num_vertexes, surf->num_triangles * 3 );
 
 	outXYZ = &tess.xyz[tess.numVertexes];
-	outNormal = &tess.normal[tess.numVertexes];
-#ifdef USE_VERT_TANGENT_SPACE
-	outTangent = &tess.tangent[tess.numVertexes];
-#endif
+	outNormal = tess.normal[tess.numVertexes];
+	outTangent = tess.tangent[tess.numVertexes];
 	outTexCoord = &tess.texCoords[tess.numVertexes];
-	outColor = &tess.vertexColors[tess.numVertexes];
+	outColor = tess.color[tess.numVertexes];
 
 	// compute interpolated joint matrices
 	if ( data->num_poses > 0 ) {
@@ -1056,7 +1052,7 @@ void RB_IQMSurfaceAnim( surfaceType_t *surface ) {
 
 	// transform vertexes and fill other data
 	for( i = 0; i < surf->num_vertexes;
-	     i++, outXYZ++, outNormal++, outTexCoord++, outColor++ ) {
+	     i++, outXYZ++, outNormal+=4, outTexCoord++, outColor+=4 ) {
 		int	j, k;
 		float	vtxMat[12];
 		float	nrmMat[9];
@@ -1100,10 +1096,8 @@ void RB_IQMSurfaceAnim( surfaceType_t *surface ) {
 		nrmMat[ 7] = vtxMat[ 2]*vtxMat[ 4] - vtxMat[ 0]*vtxMat[ 6];
 		nrmMat[ 8] = vtxMat[ 0]*vtxMat[ 5] - vtxMat[ 1]*vtxMat[ 4];
 
-		(*outTexCoord)[0][0] = data->texcoords[2*vtx + 0];
-		(*outTexCoord)[0][1] = data->texcoords[2*vtx + 1];
-		(*outTexCoord)[1][0] = (*outTexCoord)[0][0];
-		(*outTexCoord)[1][1] = (*outTexCoord)[0][1];
+		(*outTexCoord)[0] = data->texcoords[2*vtx + 0];
+		(*outTexCoord)[1] = data->texcoords[2*vtx + 1];
 
 		(*outXYZ)[0] =
 			vtxMat[ 0] * data->positions[3*vtx+0] +
@@ -1130,22 +1124,21 @@ void RB_IQMSurfaceAnim( surfaceType_t *surface ) {
 			normal[1] = DotProduct(&nrmMat[3], &data->normals[3*vtx]);
 			normal[2] = DotProduct(&nrmMat[6], &data->normals[3*vtx]);
 
-			R_VaoPackNormal((byte *)outNormal, normal);
+			R_VaoPackNormal(outNormal, normal);
 
-#ifdef USE_VERT_TANGENT_SPACE
 			tangent[0] = DotProduct(&nrmMat[0], &data->tangents[4*vtx]);
 			tangent[1] = DotProduct(&nrmMat[3], &data->tangents[4*vtx]);
 			tangent[2] = DotProduct(&nrmMat[6], &data->tangents[4*vtx]);
 			tangent[3] = data->tangents[4*vtx+3];
 
-			R_VaoPackTangent((byte *)outTangent++, tangent);
-#endif
+			R_VaoPackTangent(outTangent, tangent);
+			outTangent+=4;
 		}
 
-		(*outColor)[0] = data->colors[4*vtx+0] / 255.0f;
-		(*outColor)[1] = data->colors[4*vtx+1] / 255.0f;
-		(*outColor)[2] = data->colors[4*vtx+2] / 255.0f;
-		(*outColor)[3] = data->colors[4*vtx+3] / 255.0f;
+		outColor[0] = data->colors[4*vtx+0] * 257;
+		outColor[1] = data->colors[4*vtx+1] * 257;
+		outColor[2] = data->colors[4*vtx+2] * 257;
+		outColor[3] = data->colors[4*vtx+3] * 257;
 	}
 
 	tri = data->triangles + 3 * surf->first_triangle;
diff --git a/src/renderergl2/tr_scene.c b/src/renderergl2/tr_scene.c
index 2410804..46a00eb 100644
--- a/src/renderergl2/tr_scene.c
+++ b/src/renderergl2/tr_scene.c
@@ -330,18 +330,12 @@ void RE_BeginScene(const refdef_t *fd)
 
 	VectorCopy(tr.sunDirection, tr.refdef.sunDir);
 	if ( (tr.refdef.rdflags & RDF_NOWORLDMODEL) || !(r_depthPrepass->value) ){
-		tr.refdef.colorScale = 1.0f;
 		VectorSet(tr.refdef.sunCol, 0, 0, 0);
 		VectorSet(tr.refdef.sunAmbCol, 0, 0, 0);
 	}
 	else
 	{
-#if defined(USE_OVERBRIGHT)
-		float scale = (1 << (r_mapOverBrightBits->integer - tr.overbrightBits)) / 255.0f;
-#else
 		float scale = (1 << r_mapOverBrightBits->integer) / 255.0f;
-#endif
-		tr.refdef.colorScale = r_forceSun->integer ? r_forceSunMapLightScale->value : tr.mapLightScale;
 
 		if (r_forceSun->integer)
 			VectorScale(tr.sunLight, scale * r_forceSunLightScale->value, tr.refdef.sunCol);
diff --git a/src/renderergl2/tr_shade.c b/src/renderergl2/tr_shade.c
index 591e608..e1052cf 100644
--- a/src/renderergl2/tr_shade.c
+++ b/src/renderergl2/tr_shade.c
@@ -447,18 +447,16 @@ static void ComputeShaderColors( shaderStage_t *pStage, vec4_t baseColor, vec4_t
 		|| ((blend & GLS_SRCBLEND_BITS) == GLS_SRCBLEND_ONE_MINUS_DST_COLOR)
 		|| ((blend & GLS_DSTBLEND_BITS) == GLS_DSTBLEND_SRC_COLOR)
 		|| ((blend & GLS_DSTBLEND_BITS) == GLS_DSTBLEND_ONE_MINUS_SRC_COLOR);
-	qboolean isWorldDraw = !(backEnd.refdef.rdflags & RDF_NOWORLDMODEL);
-	float scale = 1.0f;
 
-#if defined(USE_OVERBRIGHT)
-	float exactLight = 1.0f;
-#else
-	float exactLight = (isBlend || !isWorldDraw) ? 1.0f : (float)(1 << r_mapOverBrightBits->integer);
-#endif
+	qboolean is2DDraw = backEnd.currentEntity == &backEnd.entity2D;
+
+	float overbright = (isBlend || is2DDraw) ? 1.0f : (float)(1 << tr.overbrightBits);
+
+	fog_t *fog;
 
 	baseColor[0] = 
 	baseColor[1] =
-	baseColor[2] = exactLight;
+	baseColor[2] =
 	baseColor[3] = 1.0f;
 
 	vertColor[0] =
@@ -471,11 +469,6 @@ static void ComputeShaderColors( shaderStage_t *pStage, vec4_t baseColor, vec4_t
 	//
 	switch ( pStage->rgbGen )
 	{
-		case CGEN_IDENTITY_LIGHTING:
-			baseColor[0] = 
-			baseColor[1] =
-			baseColor[2] = tr.identityLight;
-			break;
 		case CGEN_EXACT_VERTEX:
 		case CGEN_EXACT_VERTEX_LIT:
 			baseColor[0] = 
@@ -485,7 +478,7 @@ static void ComputeShaderColors( shaderStage_t *pStage, vec4_t baseColor, vec4_t
 
 			vertColor[0] =
 			vertColor[1] =
-			vertColor[2] = exactLight;
+			vertColor[2] = overbright;
 			vertColor[3] = 1.0f;
 			break;
 		case CGEN_CONST:
@@ -495,47 +488,33 @@ static void ComputeShaderColors( shaderStage_t *pStage, vec4_t baseColor, vec4_t
 			baseColor[3] = pStage->constantColor[3] / 255.0f;
 			break;
 		case CGEN_VERTEX:
-			baseColor[0] = 
+		case CGEN_VERTEX_LIT:
+			baseColor[0] =
 			baseColor[1] =
 			baseColor[2] =
 			baseColor[3] = 0.0f;
 
 			vertColor[0] =
 			vertColor[1] =
-			vertColor[2] = tr.identityLight;
+			vertColor[2] =
 			vertColor[3] = 1.0f;
 			break;
-		case CGEN_VERTEX_LIT:
-			baseColor[0] = 
-			baseColor[1] =
-			baseColor[2] = 
-			baseColor[3] = 0.0f;
-
-			vertColor[0] =
-			vertColor[1] =
-			vertColor[2] = 
-			vertColor[3] = tr.identityLight;
-			break;
 		case CGEN_ONE_MINUS_VERTEX:
 			baseColor[0] = 
 			baseColor[1] =
-			baseColor[2] = tr.identityLight;
+			baseColor[2] = 1.0f;
 
 			vertColor[0] =
 			vertColor[1] =
-			vertColor[2] = -tr.identityLight;
+			vertColor[2] = -1.0f;
 			break;
 		case CGEN_FOG:
-			{
-				fog_t		*fog;
+			fog = tr.world->fogs + tess.fogNum;
 
-				fog = tr.world->fogs + tess.fogNum;
-
-				baseColor[0] = ((unsigned char *)(&fog->colorInt))[0] / 255.0f;
-				baseColor[1] = ((unsigned char *)(&fog->colorInt))[1] / 255.0f;
-				baseColor[2] = ((unsigned char *)(&fog->colorInt))[2] / 255.0f;
-				baseColor[3] = ((unsigned char *)(&fog->colorInt))[3] / 255.0f;
-			}
+			baseColor[0] = ((unsigned char *)(&fog->colorInt))[0] / 255.0f;
+			baseColor[1] = ((unsigned char *)(&fog->colorInt))[1] / 255.0f;
+			baseColor[2] = ((unsigned char *)(&fog->colorInt))[2] / 255.0f;
+			baseColor[3] = ((unsigned char *)(&fog->colorInt))[3] / 255.0f;
 			break;
 		case CGEN_WAVEFORM:
 			baseColor[0] = 
@@ -562,6 +541,11 @@ static void ComputeShaderColors( shaderStage_t *pStage, vec4_t baseColor, vec4_t
 			break;
 		case CGEN_IDENTITY:
 		case CGEN_LIGHTING_DIFFUSE:
+			baseColor[0] =
+			baseColor[1] =
+			baseColor[2] = overbright;
+			break;
+		case CGEN_IDENTITY_LIGHTING:
 		case CGEN_BAD:
 			break;
 	}
@@ -612,18 +596,6 @@ static void ComputeShaderColors( shaderStage_t *pStage, vec4_t baseColor, vec4_t
 			break;
 	}
 
-	if (tr.overbrightBits && !isBlend)
-		scale *= 1 << tr.overbrightBits;
-
-	if ((backEnd.refdef.colorScale != 1.0f) && !isBlend && isWorldDraw)
-		scale *= backEnd.refdef.colorScale;
-
-	if (scale != 1.0f)
-	{
-		VectorScale(baseColor, scale, baseColor);
-		VectorScale(vertColor, scale, vertColor);
-	}
-
 	// FIXME: find some way to implement this.
 #if 0
 	// if in greyscale rendering mode turn all color values into greyscale.
@@ -1053,9 +1025,7 @@ static unsigned int RB_CalcShaderVertexAttribs( shaderCommands_t *input )
 		if (vertexAttribs & ATTR_NORMAL)
 		{
 			vertexAttribs |= ATTR_NORMAL2;
-#ifdef USE_VERT_TANGENT_SPACE
 			vertexAttribs |= ATTR_TANGENT2;
-#endif
 		}
 	}
 
diff --git a/src/renderergl2/tr_shade_calc.c b/src/renderergl2/tr_shade_calc.c
index c022252..263a44c 100644
--- a/src/renderergl2/tr_shade_calc.c
+++ b/src/renderergl2/tr_shade_calc.c
@@ -117,16 +117,16 @@ void RB_CalcDeformVertexes( deformStage_t *ds )
 	vec3_t	offset;
 	float	scale;
 	float	*xyz = ( float * ) tess.xyz;
-	uint32_t	*normal = tess.normal;
+	int16_t	*normal = tess.normal[0];
 	float	*table;
 
 	if ( ds->deformationWave.frequency == 0 )
 	{
 		scale = EvalWaveForm( &ds->deformationWave );
 
-		for ( i = 0; i < tess.numVertexes; i++, xyz += 4, normal++ )
+		for ( i = 0; i < tess.numVertexes; i++, xyz += 4, normal += 4 )
 		{
-			R_VaoUnpackNormal(offset, *normal);
+			R_VaoUnpackNormal(offset, normal);
 			
 			xyz[0] += offset[0] * scale;
 			xyz[1] += offset[1] * scale;
@@ -137,7 +137,7 @@ void RB_CalcDeformVertexes( deformStage_t *ds )
 	{
 		table = TableForFunc( ds->deformationWave.func );
 
-		for ( i = 0; i < tess.numVertexes; i++, xyz += 4, normal++ )
+		for ( i = 0; i < tess.numVertexes; i++, xyz += 4, normal += 4 )
 		{
 			float off = ( xyz[0] + xyz[1] + xyz[2] ) * ds->deformationSpread;
 
@@ -146,7 +146,7 @@ void RB_CalcDeformVertexes( deformStage_t *ds )
 				ds->deformationWave.phase + off,
 				ds->deformationWave.frequency );
 
-			R_VaoUnpackNormal(offset, *normal);
+			R_VaoUnpackNormal(offset, normal);
 
 			xyz[0] += offset[0] * scale;
 			xyz[1] += offset[1] * scale;
@@ -166,12 +166,12 @@ void RB_CalcDeformNormals( deformStage_t *ds ) {
 	int i;
 	float	scale;
 	float	*xyz = ( float * ) tess.xyz;
-	uint32_t *normal = tess.normal;
+	int16_t *normal = tess.normal[0];
 
-	for ( i = 0; i < tess.numVertexes; i++, xyz += 4, normal++ ) {
+	for ( i = 0; i < tess.numVertexes; i++, xyz += 4, normal += 4 ) {
 		vec3_t fNormal;
 
-		R_VaoUnpackNormal(fNormal, *normal);
+		R_VaoUnpackNormal(fNormal, normal);
 
 		scale = 0.98f;
 		scale = R_NoiseGet4f( xyz[0] * scale, xyz[1] * scale, xyz[2] * scale,
@@ -190,7 +190,7 @@ void RB_CalcDeformNormals( deformStage_t *ds ) {
 
 		VectorNormalizeFast( fNormal );
 
-		R_VaoPackNormal((byte *)normal, fNormal);
+		R_VaoPackNormal(normal, fNormal);
 	}
 }
 
@@ -204,17 +204,17 @@ void RB_CalcBulgeVertexes( deformStage_t *ds ) {
 	int i;
 	const float *st = ( const float * ) tess.texCoords[0];
 	float		*xyz = ( float * ) tess.xyz;
-	uint32_t		*normal = tess.normal;
+	int16_t	*normal = tess.normal[0];
 	float		now;
 
 	now = backEnd.refdef.time * ds->bulgeSpeed * 0.001f;
 
-	for ( i = 0; i < tess.numVertexes; i++, xyz += 4, st += 4, normal++ ) {
+	for ( i = 0; i < tess.numVertexes; i++, xyz += 4, st += 2, normal += 4 ) {
 		int		off;
 		float scale;
 		vec3_t fNormal;
 
-		R_VaoUnpackNormal(fNormal, *normal);
+		R_VaoUnpackNormal(fNormal, normal);
 
 		off = (float)( FUNCTABLE_SIZE / (M_PI*2) ) * ( st[0] * ds->bulgeWidth + now );
 
@@ -385,6 +385,7 @@ static void AutospriteDeform( void ) {
 	}
 
 	for ( i = 0 ; i < oldVerts ; i+=4 ) {
+		vec4_t color;
 		// find the midpoint
 		xyz = tess.xyz[i];
 
@@ -415,7 +416,8 @@ static void AutospriteDeform( void ) {
       VectorScale(up, axisLength, up);
     }
 
-		RB_AddQuadStamp( mid, left, up, tess.vertexColors[i] );
+		VectorScale4(tess.color[i], 1.0f / 65535.0f, color);
+		RB_AddQuadStamp( mid, left, up, color );
 	}
 }
 
diff --git a/src/renderergl2/tr_shader.c b/src/renderergl2/tr_shader.c
index 2cac049..67a8209 100644
--- a/src/renderergl2/tr_shader.c
+++ b/src/renderergl2/tr_shader.c
@@ -1828,10 +1828,12 @@ static qboolean ParseShader( char **text )
 			if (isGL2Sun)
 			{
 				token = COM_ParseExt( text, qfalse );
-				tr.mapLightScale = atof(token);
+				tr.sunShadowScale = atof(token);
 
+				// parse twice, since older shaders may include mapLightScale before sunShadowScale
 				token = COM_ParseExt( text, qfalse );
-				tr.sunShadowScale = atof(token);
+				if (token[0])
+					tr.sunShadowScale = atof(token);
 			}
 
 			SkipRestOfLine( text );
@@ -2119,12 +2121,10 @@ static void ComputeVertexAttribs(void)
 		{
 			shader.vertexAttribs |= ATTR_NORMAL;
 
-#ifdef USE_VERT_TANGENT_SPACE
 			if ((pStage->glslShaderIndex & LIGHTDEF_LIGHTTYPE_MASK) && !(r_normalMapping->integer == 0 && r_specularMapping->integer == 0))
 			{
 				shader.vertexAttribs |= ATTR_TANGENT;
 			}
-#endif
 
 			switch (pStage->glslShaderIndex & LIGHTDEF_LIGHTTYPE_MASK)
 			{
@@ -2248,10 +2248,22 @@ static void CollapseStagesToLightall(shaderStage_t *diffuse,
 			image_t *normalImg;
 			imgFlags_t normalFlags = (diffuseImg->flags & ~(IMGFLAG_GENNORMALMAP | IMGFLAG_SRGB)) | IMGFLAG_NOLIGHTSCALE;
 
+			// try a normalheight image first
 			COM_StripExtension(diffuseImg->imgName, normalName, MAX_QPATH);
-			Q_strcat(normalName, MAX_QPATH, "_n");
+			Q_strcat(normalName, MAX_QPATH, "_nh");
+
+			normalImg = R_FindImageFile(normalName, IMGTYPE_NORMALHEIGHT, normalFlags);
 
-			normalImg = R_FindImageFile(normalName, IMGTYPE_NORMAL, normalFlags);
+			if (normalImg)
+			{
+				parallax = qtrue;
+			}
+			else
+			{
+				// try a normal image ("_n" suffix)
+				normalName[strlen(normalName) - 1] = '\0';
+				normalImg = R_FindImageFile(normalName, IMGTYPE_NORMAL, normalFlags);
+			}
 
 			if (normalImg)
 			{
diff --git a/src/renderergl2/tr_sky.c b/src/renderergl2/tr_sky.c
index a4f1fcc..6d5be5c 100644
--- a/src/renderergl2/tr_sky.c
+++ b/src/renderergl2/tr_sky.c
@@ -387,8 +387,8 @@ static void DrawSkySide( struct image_s *image, const int mins[2], const int max
 			tess.xyz[tess.numVertexes][2] = s_skyPoints[t][s][2];
 			tess.xyz[tess.numVertexes][3] = 1.0;
 
-			tess.texCoords[tess.numVertexes][0][0] = s_skyTexCoords[t][s][0];
-			tess.texCoords[tess.numVertexes][0][1] = s_skyTexCoords[t][s][1];
+			tess.texCoords[tess.numVertexes][0] = s_skyTexCoords[t][s][0];
+			tess.texCoords[tess.numVertexes][1] = s_skyTexCoords[t][s][1];
 
 			tess.numVertexes++;
 
@@ -449,7 +449,7 @@ static void DrawSkySide( struct image_s *image, const int mins[2], const int max
 		
 		color[0] = 
 		color[1] = 
-		color[2] = backEnd.refdef.colorScale;
+		color[2] =
 		color[3] = 1.0f;
 		GLSL_SetUniformVec4(sp, UNIFORM_BASECOLOR, color);
 
@@ -564,8 +564,8 @@ static void FillCloudySkySide( const int mins[2], const int maxs[2], qboolean ad
 		for ( s = mins[0]+HALF_SKY_SUBDIVISIONS; s <= maxs[0]+HALF_SKY_SUBDIVISIONS; s++ )
 		{
 			VectorAdd( s_skyPoints[t][s], backEnd.viewParms.or.origin, tess.xyz[tess.numVertexes] );
-			tess.texCoords[tess.numVertexes][0][0] = s_skyTexCoords[t][s][0];
-			tess.texCoords[tess.numVertexes][0][1] = s_skyTexCoords[t][s][1];
+			tess.texCoords[tess.numVertexes][0] = s_skyTexCoords[t][s][0];
+			tess.texCoords[tess.numVertexes][1] = s_skyTexCoords[t][s][1];
 
 			tess.numVertexes++;
 
diff --git a/src/renderergl2/tr_surface.c b/src/renderergl2/tr_surface.c
index 8297dd3..fa5b390 100644
--- a/src/renderergl2/tr_surface.c
+++ b/src/renderergl2/tr_surface.c
@@ -89,7 +89,8 @@ RB_AddQuadStampExt
 */
 void RB_AddQuadStampExt( vec3_t origin, vec3_t left, vec3_t up, float color[4], float s1, float t1, float s2, float t2 ) {
 	vec3_t		normal;
-	uint32_t    pNormal;
+	int16_t     iNormal[4];
+	uint16_t    iColor[4];
 	int			ndx;
 
 	RB_CheckVao(tess.vao);
@@ -127,31 +128,35 @@ void RB_AddQuadStampExt( vec3_t origin, vec3_t left, vec3_t up, float color[4],
 	// constant normal all the way around
 	VectorSubtract( vec3_origin, backEnd.viewParms.or.axis[0], normal );
 
-	R_VaoPackNormal((byte *)&pNormal, normal);
-	tess.normal[ndx] =
-	tess.normal[ndx+1] =
-	tess.normal[ndx+2] =
-	tess.normal[ndx+3] = pNormal;
+	R_VaoPackNormal(iNormal, normal);
+
+	VectorCopy4(iNormal, tess.normal[ndx]);
+	VectorCopy4(iNormal, tess.normal[ndx + 1]);
+	VectorCopy4(iNormal, tess.normal[ndx + 2]);
+	VectorCopy4(iNormal, tess.normal[ndx + 3]);
 
 	// standard square texture coordinates
-	VectorSet2(tess.texCoords[ndx  ][0], s1, t1);
-	VectorSet2(tess.texCoords[ndx  ][1], s1, t1);
+	VectorSet2(tess.texCoords[ndx], s1, t1);
+	VectorSet2(tess.lightCoords[ndx], s1, t1);
 
-	VectorSet2(tess.texCoords[ndx+1][0], s2, t1);
-	VectorSet2(tess.texCoords[ndx+1][1], s2, t1);
+	VectorSet2(tess.texCoords[ndx+1], s2, t1);
+	VectorSet2(tess.lightCoords[ndx+1], s2, t1);
 
-	VectorSet2(tess.texCoords[ndx+2][0], s2, t2);
-	VectorSet2(tess.texCoords[ndx+2][1], s2, t2);
+	VectorSet2(tess.texCoords[ndx+2], s2, t2);
+	VectorSet2(tess.lightCoords[ndx+2], s2, t2);
 
-	VectorSet2(tess.texCoords[ndx+3][0], s1, t2);
-	VectorSet2(tess.texCoords[ndx+3][1], s1, t2);
+	VectorSet2(tess.texCoords[ndx+3], s1, t2);
+	VectorSet2(tess.lightCoords[ndx+3], s1, t2);
 
 	// constant color all the way around
 	// should this be identity and let the shader specify from entity?
-	VectorCopy4(color, tess.vertexColors[ndx]);
-	VectorCopy4(color, tess.vertexColors[ndx+1]);
-	VectorCopy4(color, tess.vertexColors[ndx+2]);
-	VectorCopy4(color, tess.vertexColors[ndx+3]);
+
+	R_VaoPackColor(iColor, color);
+
+	VectorCopy4(iColor, tess.color[ndx]);
+	VectorCopy4(iColor, tess.color[ndx + 1]);
+	VectorCopy4(iColor, tess.color[ndx + 2]);
+	VectorCopy4(iColor, tess.color[ndx + 3]);
 
 	tess.numVertexes += 4;
 	tess.numIndexes += 6;
@@ -183,19 +188,19 @@ void RB_InstantQuad2(vec4_t quadVerts[4], vec2_t texCoords[4])
 	tess.firstIndex = 0;
 
 	VectorCopy4(quadVerts[0], tess.xyz[tess.numVertexes]);
-	VectorCopy2(texCoords[0], tess.texCoords[tess.numVertexes][0]);
+	VectorCopy2(texCoords[0], tess.texCoords[tess.numVertexes]);
 	tess.numVertexes++;
 
 	VectorCopy4(quadVerts[1], tess.xyz[tess.numVertexes]);
-	VectorCopy2(texCoords[1], tess.texCoords[tess.numVertexes][0]);
+	VectorCopy2(texCoords[1], tess.texCoords[tess.numVertexes]);
 	tess.numVertexes++;
 
 	VectorCopy4(quadVerts[2], tess.xyz[tess.numVertexes]);
-	VectorCopy2(texCoords[2], tess.texCoords[tess.numVertexes][0]);
+	VectorCopy2(texCoords[2], tess.texCoords[tess.numVertexes]);
 	tess.numVertexes++;
 
 	VectorCopy4(quadVerts[3], tess.xyz[tess.numVertexes]);
-	VectorCopy2(texCoords[3], tess.texCoords[tess.numVertexes][0]);
+	VectorCopy2(texCoords[3], tess.texCoords[tess.numVertexes]);
 	tess.numVertexes++;
 
 	tess.indexes[tess.numIndexes++] = 0;
@@ -294,12 +299,12 @@ static void RB_SurfacePolychain( srfPoly_t *p ) {
 	numv = tess.numVertexes;
 	for ( i = 0; i < p->numVerts; i++ ) {
 		VectorCopy( p->verts[i].xyz, tess.xyz[numv] );
-		tess.texCoords[numv][0][0] = p->verts[i].st[0];
-		tess.texCoords[numv][0][1] = p->verts[i].st[1];
-		tess.vertexColors[numv][0] = p->verts[ i ].modulate[0] / 255.0f;
-		tess.vertexColors[numv][1] = p->verts[ i ].modulate[1] / 255.0f;
-		tess.vertexColors[numv][2] = p->verts[ i ].modulate[2] / 255.0f;
-		tess.vertexColors[numv][3] = p->verts[ i ].modulate[3] / 255.0f;
+		tess.texCoords[numv][0] = p->verts[i].st[0];
+		tess.texCoords[numv][1] = p->verts[i].st[1];
+		tess.color[numv][0] = (int)p->verts[i].modulate[0] * 257;
+		tess.color[numv][1] = (int)p->verts[i].modulate[1] * 257;
+		tess.color[numv][2] = (int)p->verts[i].modulate[2] * 257;
+		tess.color[numv][3] = (int)p->verts[i].modulate[3] * 257;
 
 		numv++;
 	}
@@ -321,13 +326,11 @@ static void RB_SurfaceVertsAndIndexes( int numVerts, srfVert_t *verts, int numIn
 	glIndex_t      *inIndex;
 	srfVert_t      *dv;
 	float          *xyz, *texCoords, *lightCoords;
-	uint32_t        *lightdir;
-	uint32_t        *normal;
-#ifdef USE_VERT_TANGENT_SPACE
-	uint32_t        *tangent;
-#endif
+	int16_t        *lightdir;
+	int16_t        *normal;
+	int16_t        *tangent;
 	glIndex_t      *outIndex;
-	float          *color;
+	uint16_t       *color;
 
 	RB_CheckVao(tess.vao);
 
@@ -351,51 +354,49 @@ static void RB_SurfaceVertsAndIndexes( int numVerts, srfVert_t *verts, int numIn
 	if ( tess.shader->vertexAttribs & ATTR_NORMAL )
 	{
 		dv = verts;
-		normal = &tess.normal[ tess.numVertexes ];
-		for ( i = 0 ; i < numVerts ; i++, dv++, normal++ )
-			R_VaoPackNormal((byte *)normal, dv->normal);
+		normal = tess.normal[ tess.numVertexes ];
+		for ( i = 0 ; i < numVerts ; i++, dv++, normal+=4 )
+			VectorCopy4(dv->normal, normal);
 	}
 
-#ifdef USE_VERT_TANGENT_SPACE
 	if ( tess.shader->vertexAttribs & ATTR_TANGENT )
 	{
 		dv = verts;
-		tangent = &tess.tangent[ tess.numVertexes ];
-		for ( i = 0 ; i < numVerts ; i++, dv++, tangent++ )
-			R_VaoPackTangent((byte *)tangent, dv->tangent);
+		tangent = tess.tangent[ tess.numVertexes ];
+		for ( i = 0 ; i < numVerts ; i++, dv++, tangent+=4 )
+			VectorCopy4(dv->tangent, tangent);
 	}
-#endif
 
 	if ( tess.shader->vertexAttribs & ATTR_TEXCOORD )
 	{
 		dv = verts;
-		texCoords = tess.texCoords[ tess.numVertexes ][0];
-		for ( i = 0 ; i < numVerts ; i++, dv++, texCoords+=4 )
+		texCoords = tess.texCoords[tess.numVertexes];
+		for ( i = 0 ; i < numVerts ; i++, dv++, texCoords+=2 )
 			VectorCopy2(dv->st, texCoords);
 	}
 
 	if ( tess.shader->vertexAttribs & ATTR_LIGHTCOORD )
 	{
 		dv = verts;
-		lightCoords = tess.texCoords[ tess.numVertexes ][1];
-		for ( i = 0 ; i < numVerts ; i++, dv++, lightCoords+=4 )
+		lightCoords = tess.lightCoords[ tess.numVertexes ];
+		for ( i = 0 ; i < numVerts ; i++, dv++, lightCoords+=2 )
 			VectorCopy2(dv->lightmap, lightCoords);
 	}
 
 	if ( tess.shader->vertexAttribs & ATTR_COLOR )
 	{
 		dv = verts;
-		color = tess.vertexColors[ tess.numVertexes ];
+		color = tess.color[ tess.numVertexes ];
 		for ( i = 0 ; i < numVerts ; i++, dv++, color+=4 )
-			VectorCopy4(dv->vertexColors, color);
+			VectorCopy4(dv->color, color);
 	}
 
 	if ( tess.shader->vertexAttribs & ATTR_LIGHTDIRECTION )
 	{
 		dv = verts;
-		lightdir = &tess.lightdir[ tess.numVertexes ];
-		for ( i = 0 ; i < numVerts ; i++, dv++, lightdir++ )
-			R_VaoPackNormal((byte *)lightdir, dv->lightdir);
+		lightdir = tess.lightdir[ tess.numVertexes ];
+		for ( i = 0 ; i < numVerts ; i++, dv++, lightdir+=4 )
+			VectorCopy4(dv->lightdir, lightdir);
 	}
 
 #if 0  // nothing even uses vertex dlightbits
@@ -641,36 +642,36 @@ static void DoRailCore( const vec3_t start, const vec3_t end, const vec3_t up, f
 
 	// FIXME: use quad stamp?
 	VectorMA( start, spanWidth, up, tess.xyz[tess.numVertexes] );
-	tess.texCoords[tess.numVertexes][0][0] = 0;
-	tess.texCoords[tess.numVertexes][0][1] = 0;
-	tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0] * 0.25 / 255.0f;
-	tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1] * 0.25 / 255.0f;
-	tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2] * 0.25 / 255.0f;
+	tess.texCoords[tess.numVertexes][0] = 0;
+	tess.texCoords[tess.numVertexes][1] = 0;
+	tess.color[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0] * 0.25f * 257.0f;
+	tess.color[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1] * 0.25f * 257.0f;
+	tess.color[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2] * 0.25f * 257.0f;
 	tess.numVertexes++;
 
 	VectorMA( start, spanWidth2, up, tess.xyz[tess.numVertexes] );
-	tess.texCoords[tess.numVertexes][0][0] = 0;
-	tess.texCoords[tess.numVertexes][0][1] = 1;
-	tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0] / 255.0f;
-	tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1] / 255.0f;
-	tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2] / 255.0f;
+	tess.texCoords[tess.numVertexes][0] = 0;
+	tess.texCoords[tess.numVertexes][1] = 1;
+	tess.color[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0] * 257;
+	tess.color[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1] * 257;
+	tess.color[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2] * 257;
 	tess.numVertexes++;
 
 	VectorMA( end, spanWidth, up, tess.xyz[tess.numVertexes] );
 
-	tess.texCoords[tess.numVertexes][0][0] = t;
-	tess.texCoords[tess.numVertexes][0][1] = 0;
-	tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0] / 255.0f;
-	tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1] / 255.0f;
-	tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2] / 255.0f;
+	tess.texCoords[tess.numVertexes][0] = t;
+	tess.texCoords[tess.numVertexes][1] = 0;
+	tess.color[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0] * 257;
+	tess.color[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1] * 257;
+	tess.color[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2] * 257;
 	tess.numVertexes++;
 
 	VectorMA( end, spanWidth2, up, tess.xyz[tess.numVertexes] );
-	tess.texCoords[tess.numVertexes][0][0] = t;
-	tess.texCoords[tess.numVertexes][0][1] = 1;
-	tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0] / 255.0f;
-	tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1] / 255.0f;
-	tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2] / 255.0f;
+	tess.texCoords[tess.numVertexes][0] = t;
+	tess.texCoords[tess.numVertexes][1] = 1;
+	tess.color[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0] * 257;
+	tess.color[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1] * 257;
+	tess.color[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2] * 257;
 	tess.numVertexes++;
 
 	tess.indexes[tess.numIndexes++] = vbase;
@@ -725,11 +726,11 @@ static void DoRailDiscs( int numSegs, const vec3_t start, const vec3_t dir, cons
 		for ( j = 0; j < 4; j++ )
 		{
 			VectorCopy( pos[j], tess.xyz[tess.numVertexes] );
-			tess.texCoords[tess.numVertexes][0][0] = ( j < 2 );
-			tess.texCoords[tess.numVertexes][0][1] = ( j && j != 3 );
-			tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0] / 255.0f;
-			tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1] / 255.0f;
-			tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2] / 255.0f;
+			tess.texCoords[tess.numVertexes][0] = (j < 2);
+			tess.texCoords[tess.numVertexes][1] = (j && j != 3);
+			tess.color[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0] * 257;
+			tess.color[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1] * 257;
+			tess.color[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2] * 257;
 			tess.numVertexes++;
 
 			VectorAdd( pos[j], dir, pos[j] );
@@ -842,308 +843,19 @@ static void RB_SurfaceLightningBolt( void ) {
 	}
 }
 
-#if 0
-/*
-** VectorArrayNormalize
-*
-* The inputs to this routing seem to always be close to length = 1.0 (about 0.6 to 2.0)
-* This means that we don't have to worry about zero length or enormously long vectors.
-*/
-static void VectorArrayNormalize(vec4_t *normals, unsigned int count)
-{
-//    assert(count);
-        
-#if idppc
-    {
-        register float half = 0.5;
-        register float one  = 1.0;
-        float *components = (float *)normals;
-        
-        // Vanilla PPC code, but since PPC has a reciprocal square root estimate instruction,
-        // runs *much* faster than calling sqrt().  We'll use a single Newton-Raphson
-        // refinement step to get a little more precision.  This seems to yeild results
-        // that are correct to 3 decimal places and usually correct to at least 4 (sometimes 5).
-        // (That is, for the given input range of about 0.6 to 2.0).
-        do {
-            float x, y, z;
-            float B, y0, y1;
-            
-            x = components[0];
-            y = components[1];
-            z = components[2];
-            components += 4;
-            B = x*x + y*y + z*z;
-
-#ifdef __GNUC__            
-            asm("frsqrte %0,%1" : "=f" (y0) : "f" (B));
-#else
-			y0 = __frsqrte(B);
-#endif
-            y1 = y0 + half*y0*(one - B*y0*y0);
-
-            x = x * y1;
-            y = y * y1;
-            components[-4] = x;
-            z = z * y1;
-            components[-3] = y;
-            components[-2] = z;
-        } while(count--);
-    }
-#else // No assembly version for this architecture, or C_ONLY defined
-	// given the input, it's safe to call VectorNormalizeFast
-    while (count--) {
-        VectorNormalizeFast(normals[0]);
-        normals++;
-    }
-#endif
-
-}
-#endif
-
-
 
-/*
-** LerpMeshVertexes
-*/
-#if 0
-#if idppc_altivec
-static void LerpMeshVertexes_altivec(md3Surface_t *surf, float backlerp)
-{
-	short	*oldXyz, *newXyz, *oldNormals, *newNormals;
-	float	*outXyz, *outNormal;
-	float	oldXyzScale QALIGN(16);
-	float   newXyzScale QALIGN(16);
-	float	oldNormalScale QALIGN(16);
-	float newNormalScale QALIGN(16);
-	int		vertNum;
-	unsigned lat, lng;
-	int		numVerts;
-
-	outXyz = tess.xyz[tess.numVertexes];
-	outNormal = tess.normal[tess.numVertexes];
-
-	newXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
-		+ (backEnd.currentEntity->e.frame * surf->numVerts * 4);
-	newNormals = newXyz + 3;
-
-	newXyzScale = MD3_XYZ_SCALE * (1.0 - backlerp);
-	newNormalScale = 1.0 - backlerp;
-
-	numVerts = surf->numVerts;
-
-	if ( backlerp == 0 ) {
-		vector signed short newNormalsVec0;
-		vector signed short newNormalsVec1;
-		vector signed int newNormalsIntVec;
-		vector float newNormalsFloatVec;
-		vector float newXyzScaleVec;
-		vector unsigned char newNormalsLoadPermute;
-		vector unsigned char newNormalsStorePermute;
-		vector float zero;
-		
-		newNormalsStorePermute = vec_lvsl(0,(float *)&newXyzScaleVec);
-		newXyzScaleVec = *(vector float *)&newXyzScale;
-		newXyzScaleVec = vec_perm(newXyzScaleVec,newXyzScaleVec,newNormalsStorePermute);
-		newXyzScaleVec = vec_splat(newXyzScaleVec,0);		
-		newNormalsLoadPermute = vec_lvsl(0,newXyz);
-		newNormalsStorePermute = vec_lvsr(0,outXyz);
-		zero = (vector float)vec_splat_s8(0);
-		//
-		// just copy the vertexes
-		//
-		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
-			newXyz += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
-		{
-			newNormalsLoadPermute = vec_lvsl(0,newXyz);
-			newNormalsStorePermute = vec_lvsr(0,outXyz);
-			newNormalsVec0 = vec_ld(0,newXyz);
-			newNormalsVec1 = vec_ld(16,newXyz);
-			newNormalsVec0 = vec_perm(newNormalsVec0,newNormalsVec1,newNormalsLoadPermute);
-			newNormalsIntVec = vec_unpackh(newNormalsVec0);
-			newNormalsFloatVec = vec_ctf(newNormalsIntVec,0);
-			newNormalsFloatVec = vec_madd(newNormalsFloatVec,newXyzScaleVec,zero);
-			newNormalsFloatVec = vec_perm(newNormalsFloatVec,newNormalsFloatVec,newNormalsStorePermute);
-			//outXyz[0] = newXyz[0] * newXyzScale;
-			//outXyz[1] = newXyz[1] * newXyzScale;
-			//outXyz[2] = newXyz[2] * newXyzScale;
-
-			lat = ( newNormals[0] >> 8 ) & 0xff;
-			lng = ( newNormals[0] & 0xff );
-			lat *= (FUNCTABLE_SIZE/256);
-			lng *= (FUNCTABLE_SIZE/256);
-
-			// decode X as cos( lat ) * sin( long )
-			// decode Y as sin( lat ) * sin( long )
-			// decode Z as cos( long )
-
-			outNormal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
-			outNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
-			outNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
-
-			vec_ste(newNormalsFloatVec,0,outXyz);
-			vec_ste(newNormalsFloatVec,4,outXyz);
-			vec_ste(newNormalsFloatVec,8,outXyz);
-		}
-	} else {
-		//
-		// interpolate and copy the vertex and normal
-		//
-		oldXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
-			+ (backEnd.currentEntity->e.oldframe * surf->numVerts * 4);
-		oldNormals = oldXyz + 3;
-
-		oldXyzScale = MD3_XYZ_SCALE * backlerp;
-		oldNormalScale = backlerp;
-
-		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
-			oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
-		{
-			vec3_t uncompressedOldNormal, uncompressedNewNormal;
-
-			// interpolate the xyz
-			outXyz[0] = oldXyz[0] * oldXyzScale + newXyz[0] * newXyzScale;
-			outXyz[1] = oldXyz[1] * oldXyzScale + newXyz[1] * newXyzScale;
-			outXyz[2] = oldXyz[2] * oldXyzScale + newXyz[2] * newXyzScale;
-
-			// FIXME: interpolate lat/long instead?
-			lat = ( newNormals[0] >> 8 ) & 0xff;
-			lng = ( newNormals[0] & 0xff );
-			lat *= 4;
-			lng *= 4;
-			uncompressedNewNormal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
-			uncompressedNewNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
-			uncompressedNewNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
-
-			lat = ( oldNormals[0] >> 8 ) & 0xff;
-			lng = ( oldNormals[0] & 0xff );
-			lat *= 4;
-			lng *= 4;
-
-			uncompressedOldNormal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
-			uncompressedOldNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
-			uncompressedOldNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
-
-			outNormal[0] = uncompressedOldNormal[0] * oldNormalScale + uncompressedNewNormal[0] * newNormalScale;
-			outNormal[1] = uncompressedOldNormal[1] * oldNormalScale + uncompressedNewNormal[1] * newNormalScale;
-			outNormal[2] = uncompressedOldNormal[2] * oldNormalScale + uncompressedNewNormal[2] * newNormalScale;
-
-//			VectorNormalize (outNormal);
-		}
-    	VectorArrayNormalize((vec4_t *)tess.normal[tess.numVertexes], numVerts);
-   	}
-}
-#endif
-#endif
-
-static void LerpMeshVertexes_scalar(mdvSurface_t *surf, float backlerp)
+static void LerpMeshVertexes(mdvSurface_t *surf, float backlerp)
 {
-#if 0
-	short	*oldXyz, *newXyz, *oldNormals, *newNormals;
-	float	*outXyz, *outNormal;
-	float	oldXyzScale, newXyzScale;
-	float	oldNormalScale, newNormalScale;
-	int		vertNum;
-	unsigned lat, lng;
-	int		numVerts;
-
-	outXyz = tess.xyz[tess.numVertexes];
-	outNormal = tess.normal[tess.numVertexes];
-
-	newXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
-		+ (backEnd.currentEntity->e.frame * surf->numVerts * 4);
-	newNormals = newXyz + 3;
-
-	newXyzScale = MD3_XYZ_SCALE * (1.0 - backlerp);
-	newNormalScale = 1.0 - backlerp;
-
-	numVerts = surf->numVerts;
-
-	if ( backlerp == 0 ) {
-		//
-		// just copy the vertexes
-		//
-		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
-			newXyz += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
-		{
-
-			outXyz[0] = newXyz[0] * newXyzScale;
-			outXyz[1] = newXyz[1] * newXyzScale;
-			outXyz[2] = newXyz[2] * newXyzScale;
-
-			lat = ( newNormals[0] >> 8 ) & 0xff;
-			lng = ( newNormals[0] & 0xff );
-			lat *= (FUNCTABLE_SIZE/256);
-			lng *= (FUNCTABLE_SIZE/256);
-
-			// decode X as cos( lat ) * sin( long )
-			// decode Y as sin( lat ) * sin( long )
-			// decode Z as cos( long )
-
-			outNormal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
-			outNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
-			outNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
-		}
-	} else {
-		//
-		// interpolate and copy the vertex and normal
-		//
-		oldXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
-			+ (backEnd.currentEntity->e.oldframe * surf->numVerts * 4);
-		oldNormals = oldXyz + 3;
-
-		oldXyzScale = MD3_XYZ_SCALE * backlerp;
-		oldNormalScale = backlerp;
-
-		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
-			oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
-		{
-			vec3_t uncompressedOldNormal, uncompressedNewNormal;
-
-			// interpolate the xyz
-			outXyz[0] = oldXyz[0] * oldXyzScale + newXyz[0] * newXyzScale;
-			outXyz[1] = oldXyz[1] * oldXyzScale + newXyz[1] * newXyzScale;
-			outXyz[2] = oldXyz[2] * oldXyzScale + newXyz[2] * newXyzScale;
-
-			// FIXME: interpolate lat/long instead?
-			lat = ( newNormals[0] >> 8 ) & 0xff;
-			lng = ( newNormals[0] & 0xff );
-			lat *= 4;
-			lng *= 4;
-			uncompressedNewNormal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
-			uncompressedNewNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
-			uncompressedNewNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
-
-			lat = ( oldNormals[0] >> 8 ) & 0xff;
-			lng = ( oldNormals[0] & 0xff );
-			lat *= 4;
-			lng *= 4;
-
-			uncompressedOldNormal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
-			uncompressedOldNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
-			uncompressedOldNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
-
-			outNormal[0] = uncompressedOldNormal[0] * oldNormalScale + uncompressedNewNormal[0] * newNormalScale;
-			outNormal[1] = uncompressedOldNormal[1] * oldNormalScale + uncompressedNewNormal[1] * newNormalScale;
-			outNormal[2] = uncompressedOldNormal[2] * oldNormalScale + uncompressedNewNormal[2] * newNormalScale;
-
-//			VectorNormalize (outNormal);
-		}
-    	VectorArrayNormalize((vec4_t *)tess.normal[tess.numVertexes], numVerts);
-   	}
-#endif
 	float *outXyz;
-	uint32_t *outNormal;
+	int16_t *outNormal, *outTangent;
 	mdvVertex_t *newVerts;
 	int		vertNum;
 
 	newVerts = surf->verts + backEnd.currentEntity->e.frame * surf->numVerts;
 
-	outXyz =    tess.xyz[tess.numVertexes];
-	outNormal = &tess.normal[tess.numVertexes];
+	outXyz =     tess.xyz[tess.numVertexes];
+	outNormal =  tess.normal[tess.numVertexes];
+	outTangent = tess.tangent[tess.numVertexes];
 
 	if (backlerp == 0)
 	{
@@ -1153,16 +865,14 @@ static void LerpMeshVertexes_scalar(mdvSurface_t *surf, float backlerp)
 
 		for (vertNum=0 ; vertNum < surf->numVerts ; vertNum++)
 		{
-			vec3_t normal;
-
 			VectorCopy(newVerts->xyz,    outXyz);
-			VectorCopy(newVerts->normal, normal);
-
-			R_VaoPackNormal((byte *)outNormal, normal);
+			VectorCopy4(newVerts->normal, outNormal);
+			VectorCopy4(newVerts->tangent, outTangent);
 
 			newVerts++;
 			outXyz += 4;
-			outNormal++;
+			outNormal += 4;
+			outTangent += 4;
 		}
 	}
 	else
@@ -1177,37 +887,28 @@ static void LerpMeshVertexes_scalar(mdvSurface_t *surf, float backlerp)
 
 		for (vertNum=0 ; vertNum < surf->numVerts ; vertNum++)
 		{
-			vec3_t normal;
-
 			VectorLerp(newVerts->xyz,    oldVerts->xyz,    backlerp, outXyz);
-			VectorLerp(newVerts->normal, oldVerts->normal, backlerp, normal);
-			VectorNormalize(normal);
 
-			R_VaoPackNormal((byte *)outNormal, normal);
+			outNormal[0] = (int16_t)(newVerts->normal[0] * (1.0f - backlerp) + oldVerts->normal[0] * backlerp);
+			outNormal[1] = (int16_t)(newVerts->normal[1] * (1.0f - backlerp) + oldVerts->normal[1] * backlerp);
+			outNormal[2] = (int16_t)(newVerts->normal[2] * (1.0f - backlerp) + oldVerts->normal[2] * backlerp);
+			outNormal[3] = 0;
+
+			outTangent[0] = (int16_t)(newVerts->tangent[0] * (1.0f - backlerp) + oldVerts->tangent[0] * backlerp);
+			outTangent[1] = (int16_t)(newVerts->tangent[1] * (1.0f - backlerp) + oldVerts->tangent[1] * backlerp);
+			outTangent[2] = (int16_t)(newVerts->tangent[2] * (1.0f - backlerp) + oldVerts->tangent[2] * backlerp);
+			outTangent[3] = newVerts->tangent[3];
 
 			newVerts++;
 			oldVerts++;
 			outXyz += 4;
-			outNormal++;
+			outNormal += 4;
+			outTangent += 4;
 		}
 	}
 
 }
 
-static void LerpMeshVertexes(mdvSurface_t *surf, float backlerp)
-{
-#if 0
-#if idppc_altivec
-	if (com_altivec->integer) {
-		// must be in a seperate function or G3 systems will crash.
-		LerpMeshVertexes_altivec( surf, backlerp );
-		return;
-	}
-#endif // idppc_altivec
-#endif
-	LerpMeshVertexes_scalar( surf, backlerp );
-}
-
 
 /*
 =============
@@ -1244,8 +945,8 @@ static void RB_SurfaceMesh(mdvSurface_t *surface) {
 
 	numVerts = surface->numVerts;
 	for ( j = 0; j < numVerts; j++ ) {
-		tess.texCoords[Doug + j][0][0] = texCoords[j].st[0];
-		tess.texCoords[Doug + j][0][1] = texCoords[j].st[1];
+		tess.texCoords[Doug + j][0] = texCoords[j].st[0];
+		tess.texCoords[Doug + j][1] = texCoords[j].st[1];
 		// FIXME: fill in lightmapST for completeness?
 	}
 
@@ -1312,12 +1013,10 @@ static void RB_SurfaceGrid( srfBspSurface_t *srf ) {
 	int		i, j;
 	float	*xyz;
 	float	*texCoords, *lightCoords;
-	uint32_t *normal;
-#ifdef USE_VERT_TANGENT_SPACE
-	uint32_t *tangent;
-#endif
-	float   *color;
-	uint32_t *lightdir;
+	int16_t *normal;
+	int16_t *tangent;
+	uint16_t *color;
+	int16_t *lightdir;
 	srfVert_t	*dv;
 	int		rows, irows, vrows;
 	int		used;
@@ -1402,14 +1101,12 @@ static void RB_SurfaceGrid( srfBspSurface_t *srf ) {
 		numVertexes = tess.numVertexes;
 
 		xyz = tess.xyz[numVertexes];
-		normal = &tess.normal[numVertexes];
-#ifdef USE_VERT_TANGENT_SPACE
-		tangent = &tess.tangent[numVertexes];
-#endif
-		texCoords = tess.texCoords[numVertexes][0];
-		lightCoords = tess.texCoords[numVertexes][1];
-		color = tess.vertexColors[numVertexes];
-		lightdir = &tess.lightdir[numVertexes];
+		normal = tess.normal[numVertexes];
+		tangent = tess.tangent[numVertexes];
+		texCoords = tess.texCoords[numVertexes];
+		lightCoords = tess.lightCoords[numVertexes];
+		color = tess.color[numVertexes];
+		lightdir = tess.lightdir[numVertexes];
 		//vDlightBits = &tess.vertexDlightBits[numVertexes];
 
 		for ( i = 0 ; i < rows ; i++ ) {
@@ -1425,36 +1122,38 @@ static void RB_SurfaceGrid( srfBspSurface_t *srf ) {
 
 				if ( tess.shader->vertexAttribs & ATTR_NORMAL )
 				{
-					R_VaoPackNormal((byte *)normal++, dv->normal);
+					VectorCopy4(dv->normal, normal);
+					normal += 4;
 				}
 
-#ifdef USE_VERT_TANGENT_SPACE
 				if ( tess.shader->vertexAttribs & ATTR_TANGENT )
 				{
-					R_VaoPackTangent((byte *)tangent++, dv->tangent);
+					VectorCopy4(dv->tangent, tangent);
+					tangent += 4;
 				}
-#endif
+
 				if ( tess.shader->vertexAttribs & ATTR_TEXCOORD )
 				{
 					VectorCopy2(dv->st, texCoords);
-					texCoords += 4;
+					texCoords += 2;
 				}
 
 				if ( tess.shader->vertexAttribs & ATTR_LIGHTCOORD )
 				{
 					VectorCopy2(dv->lightmap, lightCoords);
-					lightCoords += 4;
+					lightCoords += 2;
 				}
 
 				if ( tess.shader->vertexAttribs & ATTR_COLOR )
 				{
-					VectorCopy4(dv->vertexColors, color);
+					VectorCopy4(dv->color, color);
 					color += 4;
 				}
 
 				if ( tess.shader->vertexAttribs & ATTR_LIGHTDIRECTION )
 				{
-					R_VaoPackNormal((byte *)lightdir++, dv->lightdir);
+					VectorCopy4(dv->lightdir, lightdir);
+					lightdir += 4;
 				}
 
 				//*vDlightBits++ = dlightBits;
@@ -1593,6 +1292,12 @@ void RB_SurfaceVaoMdvMesh(srfVaoMdvMesh_t * surface)
 
 	GLimp_LogComment("--- RB_SurfaceVaoMdvMesh ---\n");
 
+	if (ShaderRequiresCPUDeforms(tess.shader))
+	{
+		RB_SurfaceMesh(surface->mdvSurface);
+		return;
+	}
+
 	if(!surface->vao)
 		return;
 
diff --git a/src/renderergl2/tr_vbo.c b/src/renderergl2/tr_vbo.c
index b1ff3d6..0ac63a4 100644
--- a/src/renderergl2/tr_vbo.c
+++ b/src/renderergl2/tr_vbo.c
@@ -23,167 +23,45 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 #include "tr_local.h"
 
 
-union pack10_u {
-	struct {
-		signed int x:10;
-		signed int y:10;
-		signed int z:10;
-		signed int w:2;
-	} pack;
-	uint32_t i;
-};
-
-union pack8_u {
-	struct {
-		signed int x:8;
-		signed int y:8;
-		signed int z:8;
-		signed int w:8;
-	} pack;
-	uint32_t i;
-};
-
-
-int R_VaoPackTangent(byte *out, vec4_t v)
+void R_VaoPackTangent(int16_t *out, vec4_t v)
 {
-	if (glRefConfig.packedNormalDataType == GL_INT_2_10_10_10_REV)
-	{
-		union pack10_u *num = (union pack10_u *)out;
-
-		num->pack.x = v[0] * 511.0f;
-		num->pack.y = v[1] * 511.0f;
-		num->pack.z = v[2] * 511.0f;
-		num->pack.w = v[3];
-	}
-	else
-	{
-		union pack8_u *num = (union pack8_u *)out;
-
-		num->pack.x = v[0] * 127.0f;
-		num->pack.y = v[1] * 127.0f;
-		num->pack.z = v[2] * 127.0f;
-		num->pack.w = v[3] * 127.0f;
-	}
-
-	return 4;
+	out[0] = v[0] * 32767.0f + (v[0] > 0.0f ? 0.5f : -0.5f);
+	out[1] = v[1] * 32767.0f + (v[1] > 0.0f ? 0.5f : -0.5f);
+	out[2] = v[2] * 32767.0f + (v[2] > 0.0f ? 0.5f : -0.5f);
+	out[3] = v[3] * 32767.0f + (v[3] > 0.0f ? 0.5f : -0.5f);
 }
 
-int R_VaoPackNormal(byte *out, vec3_t v)
+void R_VaoPackNormal(int16_t *out, vec3_t v)
 {
-	if (glRefConfig.packedNormalDataType == GL_INT_2_10_10_10_REV)
-	{
-		union pack10_u *num = (union pack10_u *)out;
-
-		num->pack.x = v[0] * 511.0f;
-		num->pack.y = v[1] * 511.0f;
-		num->pack.z = v[2] * 511.0f;
-		num->pack.w = 0;
-	}
-	else
-	{
-		union pack8_u *num = (union pack8_u *)out;
-
-		num->pack.x = v[0] * 127.0f;
-		num->pack.y = v[1] * 127.0f;
-		num->pack.z = v[2] * 127.0f;
-		num->pack.w = 0;
-	}
-
-	return 4;
+	out[0] = v[0] * 32767.0f + (v[0] > 0.0f ? 0.5f : -0.5f);
+	out[1] = v[1] * 32767.0f + (v[1] > 0.0f ? 0.5f : -0.5f);
+	out[2] = v[2] * 32767.0f + (v[2] > 0.0f ? 0.5f : -0.5f);
+	out[3] = 0;
 }
 
-int R_VaoPackTexCoord(byte *out, vec2_t st)
+void R_VaoPackColor(uint16_t *out, vec4_t c)
 {
-	if (glRefConfig.packedTexcoordDataType == GL_HALF_FLOAT)
-	{
-		uint16_t *num = (uint16_t *)out;
-
-		*num++ = FloatToHalf(st[0]);
-		*num++ = FloatToHalf(st[1]);
-
-		return sizeof(*num) * 2;
-	}
-	else
-	{
-		float *num = (float *)out;
-
-		*num++ = st[0];
-		*num++ = st[1];
-
-		return sizeof(*num) * 2;
-	}
+	out[0] = c[0] * 65535.0f + 0.5f;
+	out[1] = c[1] * 65535.0f + 0.5f;
+	out[2] = c[2] * 65535.0f + 0.5f;
+	out[3] = c[3] * 65535.0f + 0.5f;
 }
 
-int R_VaoPackColors(byte *out, vec4_t color)
+void R_VaoUnpackTangent(vec4_t v, int16_t *pack)
 {
-	if (glRefConfig.packedTexcoordDataType == GL_HALF_FLOAT)
-	{
-		uint16_t *num = (uint16_t *)out;
-
-		*num++ = FloatToHalf(color[0]);
-		*num++ = FloatToHalf(color[1]);
-		*num++ = FloatToHalf(color[2]);
-		*num++ = FloatToHalf(color[3]);
-
-		return sizeof(*num) * 4;
-	}
-	else
-	{
-		float *num = (float *)out;
-
-		*num++ = color[0];
-		*num++ = color[1];
-		*num++ = color[2];
-		*num++ = color[3];
-
-		return sizeof(*num) * 4;
-	}
-}
-
-
-void R_VaoUnpackTangent(vec4_t v, uint32_t b)
-{
-	if (glRefConfig.packedNormalDataType == GL_INT_2_10_10_10_REV)
-	{
-		union pack10_u *num = (union pack10_u *)&b;
-
-		v[0] = num->pack.x / 511.0f;
-		v[1] = num->pack.y / 511.0f;
-		v[2] = num->pack.z / 511.0f;
-		v[3] = num->pack.w; 
-	}
-	else
-	{
-		union pack8_u *num = (union pack8_u *)&b;
-
-		v[0] = num->pack.x / 127.0f;
-		v[1] = num->pack.y / 127.0f;
-		v[2] = num->pack.z / 127.0f;
-		v[3] = num->pack.w / 127.0f; 
-	}
+	v[0] = pack[0] / 32767.0f;
+	v[1] = pack[1] / 32767.0f;
+	v[2] = pack[2] / 32767.0f;
+	v[3] = pack[3] / 32767.0f;
 }
 
-void R_VaoUnpackNormal(vec3_t v, uint32_t b)
+void R_VaoUnpackNormal(vec3_t v, int16_t *pack)
 {
-	if (glRefConfig.packedNormalDataType == GL_INT_2_10_10_10_REV)
-	{
-		union pack10_u *num = (union pack10_u *)&b;
-
-		v[0] = num->pack.x / 511.0f;
-		v[1] = num->pack.y / 511.0f;
-		v[2] = num->pack.z / 511.0f;
-	}
-	else
-	{
-		union pack8_u *num = (union pack8_u *)&b;
-
-		v[0] = num->pack.x / 127.0f;
-		v[1] = num->pack.y / 127.0f;
-		v[2] = num->pack.z / 127.0f;
-	}
+	v[0] = pack[0] / 32767.0f;
+	v[1] = pack[1] / 32767.0f;
+	v[2] = pack[2] / 32767.0f;
 }
 
-
 void Vao_SetVertexPointers(vao_t *vao)
 {
 	int attribIndex;
@@ -330,9 +208,7 @@ vao_t *R_CreateVao2(const char *name, int numVertexes, srfVert_t *verts, int num
 	// since these vertex attributes are never altered, interleave them
 	vao->attribs[ATTR_INDEX_POSITION      ].enabled = 1;
 	vao->attribs[ATTR_INDEX_NORMAL        ].enabled = 1;
-#ifdef USE_VERT_TANGENT_SPACE
 	vao->attribs[ATTR_INDEX_TANGENT       ].enabled = 1;
-#endif
 	vao->attribs[ATTR_INDEX_TEXCOORD      ].enabled = 1;
 	vao->attribs[ATTR_INDEX_LIGHTCOORD    ].enabled = 1;
 	vao->attribs[ATTR_INDEX_COLOR         ].enabled = 1;
@@ -347,30 +223,28 @@ vao_t *R_CreateVao2(const char *name, int numVertexes, srfVert_t *verts, int num
 	vao->attribs[ATTR_INDEX_LIGHTDIRECTION].count = 4;
 
 	vao->attribs[ATTR_INDEX_POSITION      ].type = GL_FLOAT;
-	vao->attribs[ATTR_INDEX_NORMAL        ].type = glRefConfig.packedNormalDataType;
-	vao->attribs[ATTR_INDEX_TANGENT       ].type = glRefConfig.packedNormalDataType;
-	vao->attribs[ATTR_INDEX_TEXCOORD      ].type = glRefConfig.packedTexcoordDataType;
-	vao->attribs[ATTR_INDEX_LIGHTCOORD    ].type = glRefConfig.packedTexcoordDataType;
-	vao->attribs[ATTR_INDEX_COLOR         ].type = glRefConfig.packedColorDataType;
-	vao->attribs[ATTR_INDEX_LIGHTDIRECTION].type = glRefConfig.packedNormalDataType;
+	vao->attribs[ATTR_INDEX_NORMAL        ].type = GL_SHORT;
+	vao->attribs[ATTR_INDEX_TANGENT       ].type = GL_SHORT;
+	vao->attribs[ATTR_INDEX_TEXCOORD      ].type = GL_FLOAT;
+	vao->attribs[ATTR_INDEX_LIGHTCOORD    ].type = GL_FLOAT;
+	vao->attribs[ATTR_INDEX_COLOR         ].type = GL_UNSIGNED_SHORT;
+	vao->attribs[ATTR_INDEX_LIGHTDIRECTION].type = GL_SHORT;
 
 	vao->attribs[ATTR_INDEX_POSITION      ].normalized = GL_FALSE;
 	vao->attribs[ATTR_INDEX_NORMAL        ].normalized = GL_TRUE;
 	vao->attribs[ATTR_INDEX_TANGENT       ].normalized = GL_TRUE;
 	vao->attribs[ATTR_INDEX_TEXCOORD      ].normalized = GL_FALSE;
 	vao->attribs[ATTR_INDEX_LIGHTCOORD    ].normalized = GL_FALSE;
-	vao->attribs[ATTR_INDEX_COLOR         ].normalized = GL_FALSE;
+	vao->attribs[ATTR_INDEX_COLOR         ].normalized = GL_TRUE;
 	vao->attribs[ATTR_INDEX_LIGHTDIRECTION].normalized = GL_TRUE;
 
 	vao->attribs[ATTR_INDEX_POSITION      ].offset = 0;        dataSize  = sizeof(verts[0].xyz);
-	vao->attribs[ATTR_INDEX_NORMAL        ].offset = dataSize; dataSize += sizeof(uint32_t);
-#ifdef USE_VERT_TANGENT_SPACE
-	vao->attribs[ATTR_INDEX_TANGENT       ].offset = dataSize; dataSize += sizeof(uint32_t);
-#endif
-	vao->attribs[ATTR_INDEX_TEXCOORD      ].offset = dataSize; dataSize += glRefConfig.packedTexcoordDataSize;
-	vao->attribs[ATTR_INDEX_LIGHTCOORD    ].offset = dataSize; dataSize += glRefConfig.packedTexcoordDataSize;
-	vao->attribs[ATTR_INDEX_COLOR         ].offset = dataSize; dataSize += glRefConfig.packedColorDataSize;
-	vao->attribs[ATTR_INDEX_LIGHTDIRECTION].offset = dataSize; dataSize += sizeof(uint32_t);
+	vao->attribs[ATTR_INDEX_NORMAL        ].offset = dataSize; dataSize += sizeof(verts[0].normal);
+	vao->attribs[ATTR_INDEX_TANGENT       ].offset = dataSize; dataSize += sizeof(verts[0].tangent);
+	vao->attribs[ATTR_INDEX_TEXCOORD      ].offset = dataSize; dataSize += sizeof(verts[0].st);
+	vao->attribs[ATTR_INDEX_LIGHTCOORD    ].offset = dataSize; dataSize += sizeof(verts[0].lightmap);
+	vao->attribs[ATTR_INDEX_COLOR         ].offset = dataSize; dataSize += sizeof(verts[0].color);
+	vao->attribs[ATTR_INDEX_LIGHTDIRECTION].offset = dataSize; dataSize += sizeof(verts[0].lightdir);
 
 	vao->attribs[ATTR_INDEX_POSITION      ].stride = dataSize;
 	vao->attribs[ATTR_INDEX_NORMAL        ].stride = dataSize;
@@ -400,24 +274,28 @@ vao_t *R_CreateVao2(const char *name, int numVertexes, srfVert_t *verts, int num
 		dataOfs += sizeof(verts[i].xyz);
 
 		// normal
-		dataOfs += R_VaoPackNormal(data + dataOfs, verts[i].normal);
+		memcpy(data + dataOfs, &verts[i].normal, sizeof(verts[i].normal));
+		dataOfs += sizeof(verts[i].normal);
 
-#ifdef USE_VERT_TANGENT_SPACE
 		// tangent
-		dataOfs += R_VaoPackTangent(data + dataOfs, verts[i].tangent);
-#endif
+		memcpy(data + dataOfs, &verts[i].tangent, sizeof(verts[i].tangent));
+		dataOfs += sizeof(verts[i].tangent);
 
 		// texcoords
-		dataOfs += R_VaoPackTexCoord(data + dataOfs, verts[i].st);
+		memcpy(data + dataOfs, &verts[i].st, sizeof(verts[i].st));
+		dataOfs += sizeof(verts[i].st);
 
 		// lightmap texcoords
-		dataOfs += R_VaoPackTexCoord(data + dataOfs, verts[i].lightmap);
+		memcpy(data + dataOfs, &verts[i].lightmap, sizeof(verts[i].lightmap));
+		dataOfs += sizeof(verts[i].lightmap);
 
 		// colors
-		dataOfs += R_VaoPackColors(data + dataOfs, verts[i].vertexColors);
+		memcpy(data + dataOfs, &verts[i].color, sizeof(verts[i].color));
+		dataOfs += sizeof(verts[i].color);
 
 		// light directions
-		dataOfs += R_VaoPackNormal(data + dataOfs, verts[i].lightdir);
+		memcpy(data + dataOfs, &verts[i].lightdir, sizeof(verts[i].lightdir));
+		dataOfs += sizeof(verts[i].lightdir);
 	}
 
 	vao->vertexesSize = dataSize;
@@ -482,8 +360,8 @@ void R_BindVao(vao_t * vao)
 		{
 			qglBindVertexArray(vao->vao);
 
-			// why you no save GL_ELEMENT_ARRAY_BUFFER binding, Intel?
-			if (1)
+			// Intel Graphics doesn't save GL_ELEMENT_ARRAY_BUFFER binding with VAO binding.
+			if (glRefConfig.intelGraphics || vao == tess.vao)
 				qglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vao->indexesIBO);
 
 			// tess VAO always has buffers bound
@@ -548,11 +426,10 @@ void R_InitVaos(void)
 
 	vertexesSize  = sizeof(tess.xyz[0]);
 	vertexesSize += sizeof(tess.normal[0]);
-#ifdef USE_VERT_TANGENT_SPACE
 	vertexesSize += sizeof(tess.tangent[0]);
-#endif
-	vertexesSize += sizeof(tess.vertexColors[0]);
-	vertexesSize += sizeof(tess.texCoords[0][0]) * 2;
+	vertexesSize += sizeof(tess.color[0]);
+	vertexesSize += sizeof(tess.texCoords[0]);
+	vertexesSize += sizeof(tess.lightCoords[0]);
 	vertexesSize += sizeof(tess.lightdir[0]);
 	vertexesSize *= SHADER_MAX_VERTEXES;
 
@@ -564,9 +441,7 @@ void R_InitVaos(void)
 
 	tess.vao->attribs[ATTR_INDEX_POSITION      ].enabled = 1;
 	tess.vao->attribs[ATTR_INDEX_NORMAL        ].enabled = 1;
-#ifdef USE_VERT_TANGENT_SPACE
 	tess.vao->attribs[ATTR_INDEX_TANGENT       ].enabled = 1;
-#endif
 	tess.vao->attribs[ATTR_INDEX_TEXCOORD      ].enabled = 1;
 	tess.vao->attribs[ATTR_INDEX_LIGHTCOORD    ].enabled = 1;
 	tess.vao->attribs[ATTR_INDEX_COLOR         ].enabled = 1;
@@ -581,51 +456,43 @@ void R_InitVaos(void)
 	tess.vao->attribs[ATTR_INDEX_LIGHTDIRECTION].count = 4;
 
 	tess.vao->attribs[ATTR_INDEX_POSITION      ].type = GL_FLOAT;
-	tess.vao->attribs[ATTR_INDEX_NORMAL        ].type = glRefConfig.packedNormalDataType;
-	tess.vao->attribs[ATTR_INDEX_TANGENT       ].type = glRefConfig.packedNormalDataType;
+	tess.vao->attribs[ATTR_INDEX_NORMAL        ].type = GL_SHORT;
+	tess.vao->attribs[ATTR_INDEX_TANGENT       ].type = GL_SHORT;
 	tess.vao->attribs[ATTR_INDEX_TEXCOORD      ].type = GL_FLOAT;
 	tess.vao->attribs[ATTR_INDEX_LIGHTCOORD    ].type = GL_FLOAT;
-	tess.vao->attribs[ATTR_INDEX_COLOR         ].type = GL_FLOAT;
-	tess.vao->attribs[ATTR_INDEX_LIGHTDIRECTION].type = glRefConfig.packedNormalDataType;
+	tess.vao->attribs[ATTR_INDEX_COLOR         ].type = GL_UNSIGNED_SHORT;
+	tess.vao->attribs[ATTR_INDEX_LIGHTDIRECTION].type = GL_SHORT;
 
 	tess.vao->attribs[ATTR_INDEX_POSITION      ].normalized = GL_FALSE;
 	tess.vao->attribs[ATTR_INDEX_NORMAL        ].normalized = GL_TRUE;
 	tess.vao->attribs[ATTR_INDEX_TANGENT       ].normalized = GL_TRUE;
 	tess.vao->attribs[ATTR_INDEX_TEXCOORD      ].normalized = GL_FALSE;
 	tess.vao->attribs[ATTR_INDEX_LIGHTCOORD    ].normalized = GL_FALSE;
-	tess.vao->attribs[ATTR_INDEX_COLOR         ].normalized = GL_FALSE;
+	tess.vao->attribs[ATTR_INDEX_COLOR         ].normalized = GL_TRUE;
 	tess.vao->attribs[ATTR_INDEX_LIGHTDIRECTION].normalized = GL_TRUE;
 
-	tess.vao->attribs[ATTR_INDEX_POSITION      ].offset = offset; offset += sizeof(tess.xyz[0])              * SHADER_MAX_VERTEXES;
-	tess.vao->attribs[ATTR_INDEX_NORMAL        ].offset = offset; offset += sizeof(tess.normal[0])           * SHADER_MAX_VERTEXES;
-#ifdef USE_VERT_TANGENT_SPACE
-	tess.vao->attribs[ATTR_INDEX_TANGENT       ].offset = offset; offset += sizeof(tess.tangent[0])          * SHADER_MAX_VERTEXES;
-#endif
-	// these next two are actually interleaved
-	tess.vao->attribs[ATTR_INDEX_TEXCOORD      ].offset = offset; 
-	tess.vao->attribs[ATTR_INDEX_LIGHTCOORD    ].offset = offset + sizeof(tess.texCoords[0][0]);
-	                                                              offset += sizeof(tess.texCoords[0][0]) * 2 * SHADER_MAX_VERTEXES;
-
-	tess.vao->attribs[ATTR_INDEX_COLOR         ].offset = offset; offset += sizeof(tess.vertexColors[0])     * SHADER_MAX_VERTEXES;
+	tess.vao->attribs[ATTR_INDEX_POSITION      ].offset = offset; offset += sizeof(tess.xyz[0])         * SHADER_MAX_VERTEXES;
+	tess.vao->attribs[ATTR_INDEX_NORMAL        ].offset = offset; offset += sizeof(tess.normal[0])      * SHADER_MAX_VERTEXES;
+	tess.vao->attribs[ATTR_INDEX_TANGENT       ].offset = offset; offset += sizeof(tess.tangent[0])     * SHADER_MAX_VERTEXES;
+	tess.vao->attribs[ATTR_INDEX_TEXCOORD      ].offset = offset; offset += sizeof(tess.texCoords[0])   * SHADER_MAX_VERTEXES;
+	tess.vao->attribs[ATTR_INDEX_LIGHTCOORD    ].offset = offset; offset += sizeof(tess.lightCoords[0]) * SHADER_MAX_VERTEXES;
+	tess.vao->attribs[ATTR_INDEX_COLOR         ].offset = offset; offset += sizeof(tess.color[0])       * SHADER_MAX_VERTEXES;
 	tess.vao->attribs[ATTR_INDEX_LIGHTDIRECTION].offset = offset;
 
 	tess.vao->attribs[ATTR_INDEX_POSITION      ].stride = sizeof(tess.xyz[0]);
 	tess.vao->attribs[ATTR_INDEX_NORMAL        ].stride = sizeof(tess.normal[0]);
-#ifdef USE_VERT_TANGENT_SPACE
 	tess.vao->attribs[ATTR_INDEX_TANGENT       ].stride = sizeof(tess.tangent[0]);
-#endif
-	tess.vao->attribs[ATTR_INDEX_COLOR         ].stride = sizeof(tess.vertexColors[0]);
-	tess.vao->attribs[ATTR_INDEX_TEXCOORD      ].stride = sizeof(tess.texCoords[0][0]) * 2;
-	tess.vao->attribs[ATTR_INDEX_LIGHTCOORD    ].stride = sizeof(tess.texCoords[0][0]) * 2;
+	tess.vao->attribs[ATTR_INDEX_TEXCOORD      ].stride = sizeof(tess.texCoords[0]);
+	tess.vao->attribs[ATTR_INDEX_LIGHTCOORD    ].stride = sizeof(tess.lightCoords[0]);
+	tess.vao->attribs[ATTR_INDEX_COLOR         ].stride = sizeof(tess.color[0]);
 	tess.vao->attribs[ATTR_INDEX_LIGHTDIRECTION].stride = sizeof(tess.lightdir[0]);
 
 	tess.attribPointers[ATTR_INDEX_POSITION]       = tess.xyz;
-	tess.attribPointers[ATTR_INDEX_TEXCOORD]       = tess.texCoords;
 	tess.attribPointers[ATTR_INDEX_NORMAL]         = tess.normal;
-#ifdef USE_VERT_TANGENT_SPACE
 	tess.attribPointers[ATTR_INDEX_TANGENT]        = tess.tangent;
-#endif
-	tess.attribPointers[ATTR_INDEX_COLOR]          = tess.vertexColors;
+	tess.attribPointers[ATTR_INDEX_TEXCOORD]       = tess.texCoords;
+	tess.attribPointers[ATTR_INDEX_LIGHTCOORD]     = tess.lightCoords;
+	tess.attribPointers[ATTR_INDEX_COLOR]          = tess.color;
 	tess.attribPointers[ATTR_INDEX_LIGHTDIRECTION] = tess.lightdir;
 
 	Vao_SetVertexPointers(tess.vao);
@@ -745,14 +612,6 @@ void RB_UpdateTessVao(unsigned int attribBits)
 
 		attribUpload = attribBits;
 
-		if((attribUpload & ATTR_TEXCOORD) || (attribUpload & ATTR_LIGHTCOORD))
-		{
-			// these are interleaved, so we update both if either need it
-			// this translates to updating ATTR_TEXCOORD twice as large as it needs
-			attribUpload &= ~ATTR_LIGHTCOORD;
-			attribUpload |= ATTR_TEXCOORD;
-		}
-
 		for (attribIndex = 0; attribIndex < ATTR_INDEX_COUNT; attribIndex++)
 		{
 			uint32_t attribBit = 1 << attribIndex;
diff --git a/src/renderergl2/tr_world.c b/src/renderergl2/tr_world.c
index 85f252d..0978ebc 100644
--- a/src/renderergl2/tr_world.c
+++ b/src/renderergl2/tr_world.c
@@ -402,11 +402,11 @@ void R_AddBrushModelSurfaces ( trRefEntity_t *ent ) {
 R_RecursiveWorldNode
 ================
 */
-static void R_RecursiveWorldNode( mnode_t *node, int planeBits, int dlightBits, int pshadowBits ) {
+static void R_RecursiveWorldNode( mnode_t *node, uint32_t planeBits, uint32_t dlightBits, uint32_t pshadowBits ) {
 
 	do {
-		int			newDlights[2];
-		unsigned int newPShadows[2];
+		uint32_t newDlights[2];
+		uint32_t newPShadows[2];
 
 		// if the node wasn't marked as potentially visible, exit
 		// pvs is skipped for depth shadows
@@ -762,7 +762,7 @@ R_AddWorldSurfaces
 =============
 */
 void R_AddWorldSurfaces (void) {
-	int planeBits, dlightBits, pshadowBits;
+	uint32_t planeBits, dlightBits, pshadowBits;
 
 	if ( !r_drawworld->integer ) {
 		return;
@@ -783,12 +783,12 @@ void R_AddWorldSurfaces (void) {
 	ClearBounds( tr.viewParms.visBounds[0], tr.viewParms.visBounds[1] );
 
 	// perform frustum culling and flag all the potentially visible surfaces
-	if ( tr.refdef.num_dlights > 32 ) {
-		tr.refdef.num_dlights = 32 ;
+	if ( tr.refdef.num_dlights > MAX_DLIGHTS ) {
+		tr.refdef.num_dlights = MAX_DLIGHTS ;
 	}
 
-	if ( tr.refdef.num_pshadows > 32 ) {
-		tr.refdef.num_pshadows = 32 ;
+	if ( tr.refdef.num_pshadows > MAX_DRAWN_PSHADOWS ) {
+		tr.refdef.num_pshadows = MAX_DRAWN_PSHADOWS;
 	}
 
 	planeBits = (tr.viewParms.flags & VPF_FARPLANEFRUSTUM) ? 31 : 15;
@@ -800,12 +800,12 @@ void R_AddWorldSurfaces (void) {
 	}
 	else if ( !(tr.viewParms.flags & VPF_SHADOWMAP) )
 	{
-		dlightBits = ( 1 << tr.refdef.num_dlights ) - 1;
-		pshadowBits = ( 1 << tr.refdef.num_pshadows ) - 1;
+		dlightBits = ( 1ULL << tr.refdef.num_dlights ) - 1;
+		pshadowBits = ( 1ULL << tr.refdef.num_pshadows ) - 1;
 	}
 	else
 	{
-		dlightBits = ( 1 << tr.refdef.num_dlights ) - 1;
+		dlightBits = ( 1ULL << tr.refdef.num_dlights ) - 1;
 		pshadowBits = 0;
 	}
 
